#!/usr/bin/env zsh
# Tooling to in-mass build many repos and inject the results into VMs

##############################################################################
# Set the script name, ulcer-core uses this to find functions and setup the environment
argv0=${${0:t}:r}

# Load the ulcer-core.zsh
ulcer_core=$(whence -p ulcer-core.zsh)
if [[ -n $ulcer_core ]]; then
	source $ulcer_core
else
	echo "Error: ulcer-core.zsh not found"
	exit 1
fi

##############################################################################
# Define the tasks for this tool

function worldbuilder_help {
  cat <<EOS
worldbuilder <task> [<args>]
  Tooling to in-mass build many repos and inject the results into VMs.

  'worldbuilder help <task>' or 'worldbuilder <task> --help' for more info on a specific task.
  'worldbuilder tasks [<prefix filter>]' to see what tasks are implemented.
  'worldbuilder state' to check ENVs, ARGs, and options.

  Options, key-values, and arguments can be interwoven as make sense.

  Key-Values:
    These get prefixed with WORLDBUILDER_, upcased, and then become environment variables.

  Environment variables:
    WORLDBUILDER_FILE
      The worldbuilder file to use. Defaults to 'wb.ini' in the current directory.
      'worldbuilder 
    WORLDBUILDER_DOCKER_TOOL
      The docker tool to use. Defaults to 'docker'.
    WORLDBUILDER_HOST
      A space separated list of hosts to inject images into. Each host is expanded with 'worldbuilder host expand'.
    WORLDBUILDER_SKIPLIST
      A comma separated list of sections to skip when using 'worldbuilder foreach' or 'worldbuilder all'.
EOS
}

function worldbuilder_help_sections {
  cat <<EOF
worldbuilder sections
  Lists all sections in the worldbuilder file.
EOF
}
function worldbuilder_sections {
  want_envs WORLDBUILDER_FILE "^.+$"

  while read -r line; do
    if [[ "$line" =~ "^\[([^]]*)\]"  ]]; then 
      echo ${match[1]}
    fi
  done < "$WORLDBUILDER_FILE"
}

function worldbuilder_help_namer {
  cat <<EOF
worldbuilder namer [query]
  Fuzzy match a section from the worldbuilder file.
EOF
}
function worldbuilder_namer {
  worldbuilder_sections | fzf -1 --no-multi --query "${1:-m}"
}

function worldbuilder_help_example {
  cat <<EOS
worldbuilder example
  Prints an example worldbuilder file section.
EOS
}
function worldbuilder_example {
  cat <<EOE
[name-of-thing]
# The name of the section is up to you, but should be unique.

# These keys are required in each section:
repo=git repo url (ssh or https)
commit=branch_to_checkout
# commit can be a branch, tag, commit hash or empty for HEAD.
dir=relative/directory/path/to/thing
image=container/name:thing
# image is the name of the docker image to build, or the name of the zip file to create.

# These keys are optional:
platform=linux/arm64|linux/amd64
# platform is only used for docker builds, and defaults to linux/arm64
# This value is passed to 'docker build --platform=…'
type=docker|build
# type defaults to docker, but can be set to 'build' for things that aren't docker images.
# If set to 'build', the build_cmd key must be set to a command that
build_cmd=command_to_build_thing
# build_cmd is only used if type is 'build'.
# This command should create a zip file at the path specified by the image key.
# build_cmd defaults to zipping up the entire directory.
build_pre_cmd=command_to_run_before_build
# build_pre_cmd is run before the build_cmd, if specified.
# This runs for all types.
build_post_cmd=command_to_run_after_build
# build_post_cmd is run after the build_cmd, if specified.
# This runs for all types.
dest=/path/to/extract/thing
# When injecting a 'build' type, this is the path to extract the zip file to.
EOE
}

function worldbuilder_help_clone {
  cat <<EOF
worldbuilder clone <section>
  Clones the repo for the section if it doesn't exist.
EOF
}
function worldbuilder_clone {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  want_envs dir "^.+$" repo "^.+$"

  if [[ ! -d "$dir" || -z "$(ls -A "$dir")" ]]; then
    mkdir -p "$dir"
    git clone "$repo" "$dir"
  fi
}

function worldbuilder_help_update {
  cat <<EOF
worldbuilder update <section>
  Fetches the latest changes for the section.
  This will stash and switch branches if the declared commit isn't the current one,
  and return back to the original branch.
EOF
}
function worldbuilder_update {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  want_envs dir "^.+$" commit "^.*$"

  (
    cd ${dir}
    git fetch --all

    # if commit is in heads, then checkout that branch and do a pull
    local heads=($(git for-each-ref --format='%(refname:short)' refs/heads/))
    if [[ " ${heads[@]} " =~ " ${commit} " ]]; then
      # Remember where things are before switching and pulling
      local remember=""
      local needs_stash=""
      needs_stash="$(git status --untracked-files=no --porcelain)"
      [[ -n "$needs_stash" ]] && git stash

      remember=$(git symbolic-ref --quiet HEAD 2>/dev/null)
      git checkout "${commit}"

      git pull

      # …and put things back
      [[ -n "$remember" ]] && git checkout "${remember#refs/heads/}"
      [[ -n "$needs_stash" ]] && git stash pop
    fi
  )
}

function worldbuilder_help_where {
  cat <<EOF
worldbuilder where <section>
  Prints the current branch for the section.
EOF
}
function worldbuilder_where {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  want_envs dir "^.+$"
  (
    cd ${dir}
    echo -n "$whom : "
    git symbolic-ref --quiet HEAD
  )
}

function worldbuilder_help_switch {
  cat <<EOF
worldbuilder switch <section> [commit]
  Switches to a commit or branch for a section.
EOF
}
function worldbuilder_switch {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  want_envs dir "^.+$" commit "^.*$"
  [[ $# -gt 1 ]] && commit=${2:-$commit}
  if [[ -z "$commit" ]]; then
    echo "No commit to switch to" >&2
    exit 1
  fi
  (
    cd ${dir}
    # echo -n "$whom : "
    git switch $commit
  )
}

function worldbuilder_help_audit {
  cat <<EOF
worldbuilder audit <section> [--verbose] [--image] -- [trivy options]
  Runs the audit tool for the section.
EOF
}
function worldbuilder_audit {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  shift
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  want_envs dir "^.+$" image "^.+$" commit "^.*$" repo "^.+$"

  local base=$PWD
  local imagesDir=_images_${${WORLDBUILDER_FILE#wb_}:r}

  local extra_args=()
  [[ -f "$HOME/.config/trivy/trivy.yaml" ]] && extra_args+=(--config "$HOME/.config/trivy/trivy.yaml")
  [[ -z "${ucr_opts[verbose]}" ]] && extra_args+=(--quiet --table-mode detailed)
  extra_args+=("$@")

  (
    cd ${dir}

    if [[ -n "$ucr_opts[image]" ]]; then
      trivy image --input ${base}/${imagesDir}/${${image/%:*}:t}.tar  "${extra_args[@]}"
    else
      set -x
      trivy repo . "${extra_args[@]}"
    fi
  )
}

function worldbuilder_help_build {
  cat <<EOF
worldbuilder build <section> [--commit <commit>] [--head]
  Builds an image from a section in the worldbuilder file.
  This will stash and switch branches if the declared commit isn't the current one,
  and return back to the original branch.

  The resulting image/archive will be saved in a directory named
  _images_<worldbuilder_file_name> in the current directory.

  The --head option will build the current HEAD of the repo.
  The --commit option will build the specified commit or branch.
  These override the commit specified in the worldbuilder file.
EOF
}
# Builds an image from a section in the worldbuilder file.
# Doing its best to be idempotent.
function worldbuilder_build {
  want_envs WORLDBUILDER_FILE "^.+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  local docker_tool=${WORLDBUILDER_DOCKER_TOOL:-docker} # or 'nerdctl' or 'nerdctl.lima'
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  [[ ! -v "type" ]] && typeset -g -x type=docker
  [[ ! -v "platform" ]] && typeset -g -x platform=linux/arm64

  want_envs dir "^.+$" image "^.+$" type "^.+$" commit "^.*$" repo "^.+$"

  local base=$PWD
  local imagesDir=_images_${${WORLDBUILDER_FILE#wb_}:r}

  [[ ${ucr_opts[head]} == "true" ]] && commit=""
  [[ -n ${ucr_opts[commit]} ]] && commit=${ucr_opts[commit]}

  (
    # set -x
    cd ${dir}
    typeset -g -x build_target=${base}/${imagesDir}/${${image/%:*}:t}.zip

    ## BUILD
    local remember=""
    local needs_stash=""
    if [[ -n "$commit" ]]; then
      needs_stash="$(git status --untracked-files=no --porcelain)"
      [[ -n "$needs_stash" ]] && git stash

      remember=$(git symbolic-ref --quiet HEAD 2>/dev/null)
      git checkout "${commit}"
    fi

    if [[ -n "$build_pre_cmd" ]]; then
      echo "Running pre-build command: ${build_pre_cmd}" >&2
      ${=build_pre_cmd}
    fi

		if [[ "$type" == "docker" ]]; then
      # Someday, rewrite _all_ the dockerfiles to use --ssh
      if grep -s murano-service-ssh-key Dockerfile >/dev/null; then
        cp ~/.ssh/murano_builder murano-service-ssh-key
      fi

      $docker_tool build \
        --label com.exosite.build.git_commit="$(git rev-parse HEAD)" \
        --tag "${image}" \
        --platform="${platform}" \
        .
      local exit_code=$?

      test -e murano-service-ssh-key && rm murano-service-ssh-key

      if [[ $exit_code = 0 ]]; then
        $docker_tool save "${image}" > ${base}/${imagesDir}/${${image/%:*}:t}.tar
      fi

    elif [[ "$type" == "build" ]]; then
      # default to zipping the entire directory
    	function zip_build() {
        zip -r -FS "$1" . -x "*.git*" 2>&1 | wc -l
        # pv -lep -s $(find . -name "*.git*" -prune -o -type fd | wc -l) > /dev/null
      }
      [[ ! -v "build_cmd" ]] && typeset -g -x build_cmd=zip_build

      # Adding a builtin build command for fetching gh-release asset.
      function gh_release() {
        # $1 is the asset we want
        # $2 is where to save it
        # Fetch the release asset from github
        if [[ -n "$commit" ]]; then
          # make sure it is a tag, because only tags can be releases
          commit=$(git describe --abbrev=0 --tags $commit)
        fi
        # when commit is empty, it will grab the latest release
        gh release download -R "$repo" "$commit" -O "$2" -p "$1" --clobber
      }

      ${=build_cmd} "${base}/${imagesDir}/${${image/%:*}:t}.zip"

    else
      echo "Unknown type: $type" >&2
      exit 1
    fi

    if [[ -n "$build_post_cmd" ]]; then
      echo "Running post-build command: ${build_post_cmd}" >&2
      ${=build_post_cmd}
    fi

    [[ -n "$remember" ]] && git checkout "${remember#refs/heads/}"
    [[ -n "$needs_stash" ]] && git stash pop
  )
}

function worldbuilder_help_host_expand {
  cat <<EOF
worldbuilder host expand <host>
  Expands a host string into a host and ssh config file.

  This is used for specifying a host in a worldbuilder file and then
  expanding it into a host and ssh config file for use in other commands.

  Currently only supports 'lima:<name>'.
EOF
}
function worldbuilder_host_expand {
  # This lets us use `<keyword>:` to expand a bunch of tedious stuff without having to build up massive config files.
  # This returns a multi-line string with the host and the ssh config file.
  local host=${1:?Need a host}
  # ??? Maybe some day allow for a trailing `:\d+` to specify a port?

  # `lima:` is the only prefix we support right now.
  if [[ "$host" == "lima:"* ]]; then
    print "lima-${host#lima:}\n${HOME}/.lima/${host#lima:}/ssh.config"
  else
    print "$host"
  fi
}

function worldbuilder_help_inject {
  cat <<EOF
worldbuilder inject <section>
  Injects the image from a section in the worldbuilder file into a host.

  The hosts are specified in the WORLDBUILDER_HOST environment variable.
  This is a space separated list of host strings that is expanded with
  the 'worldbuilder host expand' command.
EOF
}
function worldbuilder_inject {
  want_envs WORLDBUILDER_HOST "^[-@._A-Za-z0-9:]+$"
  local whom=$(worldbuilder_namer ${1:?Need section to work on})
  local imagesDir=_images_${${WORLDBUILDER_FILE#wb_}:r}
  load_from_ini "$WORLDBUILDER_FILE" "$whom"
  if [[ ! -v "type" ]]; then
    type=docker
  fi
  want_envs image "^.+$" type "^.+$"

  function upload_one {
    # TODO: Prefix all output from this function with the host
    local cfg=(${(f)"$(worldbuilder_host_expand $WORLDBUILDER_HOST)"})
    local host=${cfg[1]}
    local ssh_cfg=''
    [[ -n ${cfg[2]} ]] && ssh_cfg="-F ${cfg[2]}"
    if [[ "$type" == "docker" ]]; then
      set -e
      ssh ${=ssh_cfg} ${host} -- mkdir -p /tmp/images
      scp ${=ssh_cfg} ${imagesDir}/${${image/%:*}:t}.tar ${host}:/tmp/images/${${image/%:*}:t}.tar
      ssh ${=ssh_cfg} ${host} -- docker load -i /tmp/images/${${image/%:*}:t}.tar
      ssh ${=ssh_cfg} ${host} -- rm /tmp/images/${${image/%:*}:t}.tar
    elif [[ "$type" == "build" ]]; then
      set -e
      ssh ${=ssh_cfg} ${host} -- mkdir -p /tmp/images
      scp ${=ssh_cfg} ${imagesDir}/${${image/%:*}:t}.zip ${host}:/tmp/images/${${image/%:*}:t}.zip
      ssh ${=ssh_cfg} ${host} -- sudo mkdir -p ${${dest:-/tmp/images/barf}:h}
      ssh ${=ssh_cfg} ${host} -- sudo unzip -q -o /tmp/images/${${image/%:*}:t}.zip -d ${dest:-/tmp/images/barf}
      ssh ${=ssh_cfg} ${host} -- rm /tmp/images/${${image/%:*}:t}.zip
    else
      echo "Unknown type: $type" >&2
      exit 1
    fi
  }

  autoload -Uz zargs

  zargs -P 5 -l 1 -- ${=WORLDBUILD_HOST} -- upload_one
}

function worldbuilder_help_foreach {
  cat <<EOF
worldbuilder foreach <internal task name> [--time] [--verbose] [--show]
  Runs a task for each section in the worldbuilder file.

  WORLDBUILDER_SKIPLIST can be set to a comma separated list of sections to skip.
EOF
}
function worldbuilder_foreach {
  local start=$(date +%s)
  local cmd=${1:?Need a command to run}
  local skiplist=(${(z)${(s:,:)${WORLDBUILDER_SKIPLIST}}})
  if [[ -n "${ucr_opts[time]}" ]]; then
    date +%Y-%m-%dT%H:%M:%S%z
  fi

  for sec in $(worldbuilder_sections); do
    if [[ " ${skiplist[@]} " =~ " ${sec} " ]]; then
      continue
    fi
    if [[ -n "${ucr_opts[verbose]}" || -n "${ucr_opts[show]}" ]];then
      local msg=" Running: $cmd '$sec' "
      print -r - ${(l[COLUMNS/2][=]r[COLUMNS-COLUMNS/2][=])msg}
    fi

    # the `'` in front of the $sec is to enable fzf exact mode.
    $cmd "'$sec"
    # TODO: get the list of vars to unset from the section…
    unset image type commit repo dir platform dest build_cmd build_pre_cmd build_post_cmd
  done

  if [[ -n "${ucr_opts[time]}" ]]; then
    date +%Y-%m-%dT%H:%M:%S%z
    local stop=$(date +%s)
    echo "Took: $((stop - start))"
  fi
}

function worldbuilder_help_all {
  cat <<EOF
worldbuilder all <task> [--time] [--verbose] [--show]
  Runs a task for each section in the worldbuilder file.
  Tasks are: audit, build, clone, inject, update, where

  WORLDBUILDER_SKIPLIST can be set to a comma separated list of sections to skip.
EOF
}
function worldbuilder_all {
  local action=${1:-build}
  local allowed=(audit build clone inject update where)
  if [[ ! " ${allowed[@]} " =~ " ${action} " ]]; then
    echo "Unknown action: $action" >&2
    exit 1
  fi
  worldbuilder_foreach worldbuilder_${action}
}

##############################################################################
# Finally, run the task runner to find and run the task based on arguments
task_runner "$@"
