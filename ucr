#!/usr/bin/env zsh
# A cli to Murano solutions, for both cloud and on-prem

##############################################################################
# Set the script name, ulcer-core uses this to find functions and setup the environment
argv0=${${0:t}:r}

# Load the ulcer-core.zsh
ulcer_core=$(whence -p ulcer-core.zsh)
if [[ -n $ulcer_core ]]; then
	source $ulcer_core
else
	echo "Error: ulcer-core.zsh not found"
	exit 1
fi

##############################################################################
# Define some helper functions

# Get a murano login token and save it in env to use by following commands.
# Just smart enough not to call more than once per evocation, could save token somewhere for multiple.
# Not worth the extra work.
function get_token {
  if [[ -z "$UCR_TOKEN" ]]; then
    # echo "X: $psd" >&2
    # Murano doesn't accept basic auth…
    local req=""
    if [[ "$UCR_USER" =~ '^op:' || "$UCR_PASSWORD" =~ '^op:' ]] && (which op >/dev/null); then
      # They have 1password and are using it, so op run
      req=$(op run --no-masking -- jq -n '{"email": $ENV.UCR_USER, "password": $ENV.UCR_PASSWORD}')
    else
      echo "Only 1password is supported anymore." >&2
      exit 2
    fi
    # echo "X: $req" >&2
    export UCR_TOKEN=$(curl -s https://${UCR_BIZ_URL}/token/ -H 'Content-Type: application/json' -d "$req" | jq -r .token)
  fi
}

# Repeating this in every command gets messy; so we'll do it once here.
# all the same for now
ucr_api_url_pattern="^https?://[\.A-Za-z0-9:-]+"
ucr_dis_url_pattern="^https?://[\.A-Za-z0-9:-]+"
ucr_biz_url_pattern="^https?://[\.A-Za-z0-9:-]+"

##############################################################################
# Define the tasks for this tool

function ucr_help {
  cat <<EOF
ucr <task> [<args…>] [--opts…] [KEY=VALUE…]
  CLI to the guts of Murano; if you know, then you know. Otherwise not for you.

  'ucr help <task>' or 'ucr <task> --help' for more info on a specific task.
  'ucr tasks [<prefix filter>]' to see what tasks are implemented.
  'ucr state' to check ENVs, ARGs, and options.

  Options, key-values, and arguments can be interwoven as make sense.

  Key-Values:
    These get prefixed with UCR_, upcased, and then become environment variables.

  Environment variables:
    UCR_SID       Solution Identifier
    UCR_BID       Business Identifier
    UCR_API_URL   URL to API endpoint
    UCR_DIS_URL   URL to call runner
    UCR_BIZ_URL   URL to call business logic
EOF
}


function ucr_help_dump_script {
  cat <<EOF
ucr dump script
  Dump out the unified Lua script for a solution

  Useful to see what extra junk was actually added.
EOF
}
function ucr_dump_script {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID}/script \
    -H 'Content-Type: application/json'
}

function ucr_help_dump_source_map {
  cat <<EOF
ucr dump source map
  Dump out a map of the Lua fragments to line numbers of the unified solution script
EOF
}
function ucr_dump_source_map {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID}/sourcemap \
    -H 'Content-Type: application/json'
}

function ucr_help_flow {
  cat <<EOF
ucr flow
  Get the data-flow config for a solution
EOF
}
function ucr_flow {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID} \
    -H 'Content-Type: application/json' \
    | jq '.flow'
}

function ucr_help_flow_set {
  cat <<EOF
ucr flow set < flow_file
  Set the data-flow config for a solution.
  The flow_file should be a JSON object representing the flow.
  To update a flow use: ucr flow | jq <stuff> | ucr flow set
EOF
}
function ucr_flow_set {
  # ucr flow set < flow_file
  # or: ucr flow | jq <stuff> | ucr flow set
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local req=$(jq -c '{"flow": .}')
  v_curl -s ${UCR_API_URL}/route/${UCR_SID} \
    -H 'Content-Type: application/json' \
    -X PUT \
    -d "$req"
}

function ucr_help_env_get {
  cat <<EOF
ucr env get
  Get all solution environment variables for the solution.
EOF
}
function ucr_env_get {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json'
}

function ucr_help_env_set {
  cat <<EOF
ucr env set <key> <value> [<key <value> …] [--overwrite]
  Set one or more solution environment variables for the solution.
  By default, adds or updates keys.
  Use --overwrite to replace all prior keys with the new set.
EOF
}
function ucr_env_set {
  # <key> <value> [<key <value> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local method=PUT
  if [[ -n "$ucr_opts[overwrite]" ]]; then
    method=POST
  fi

  # build values req
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n]; . + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json' \
    -X $method \
    -d "$req"
}

function ucr_help_env_del {
  cat <<EOF
ucr env del <key> [<key> …]
  Delete one or more solution environment variables from the solution.
EOF
}
function ucr_env_del {
  # <key> [<key> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  # req is an object with each key set to null
  local req=$(jq -n -c '. + ([$ARGS.positional[]|{"key":.,"value":null}]|from_entries)' --args -- "${@}")

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json' \
    -X PUT \
    -d "$req"
}

function ucr_help_solution_info {
  cat <<EOF
ucr solution info <solution id>
  Get information about a solution
EOF
}
function ucr_solution_info {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID} \
    -H 'Content-Type: application/json'
}

function ucr_help_solution_list {
  cat <<EOF
ucr solution list [<options>]
  List all solutions
  Options:
    --business_id=<id>   Filter by business id
    --template=<type>    Filter by template type (application or m2connector)
EOF
}
function ucr_solution_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern"
  local filter='%7B%7D'
  local opt_req=$(
    options_to_json \
    business_id::string ".*" \
    template::string ".*"
  )
  [[ -n "$opt_req" ]] && filter=$(jq -n -c -r "$opt_req | @uri")
  v_curl -s ${UCR_API_URL}/solution\?query\=$filter \
    -H 'Content-Type: application/json'
}

function ucr_help_solution_create {
  cat <<EOF
ucr solution create SID=<solution id> [BID=<business id>] [--m2] [--file=<template name>] [--github=<url>] [--exchange=<ids>]
  Creates a new solution
EOF
}
function ucr_solution_create {
  # ucr solution create SID=<new id> [BID=<business id>] [--m2] [--file=<template name>] [--github=<url>] [--exchange=<ids>]
  want_envs UCR_API_URL "$ucr_api_url_pattern" \
    UCR_SID "^[a-zA-Z0-9]+$" \
    UCR_BID "^[a-zA-Z0-9]+$"
  local domain=${1:?Need domain}
  local type="application" # or m2connector
  if [[ -n "$ucr_opts[m2]" ]]; then
    type="m2connector"
  fi
  local template='{}'
  if [[ -n "$ucr_opts[file]" ]]; then
    template='{"source":{ "from": "file", "path": "/tmp/custom-solution-templates/'"$ucr_opts[file]"'"}}'
  fi
  if [[ -n "$ucr_opts[github]" ]]; then
    template='{"source":{ "from": "github", "url": "'"$ucr_opts[github]"'"}}'
  fi
  local exchangelist=''
  if [[ -n "$ucr_opts[exchange]" ]]; then
    exchangelist="X-exosite-exchange-id: $ucr_opts[exchange]"
  fi

  local req=$(jq -n -c --arg type "$type" --arg domain "$domain" --argjson template "$template" '{
				"name": $ENV.UCR_SID,
				"domain": $domain,
				"business_id": $ENV.UCR_BID,
				"template": $type,
				"services": [],
				"env": {},
			} + $template')

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID} \
    -H 'Content-Type: application/json' \
    -H "$exchangelist" \
    -d "$req"

}

function ucr_help_solution_delete {
  cat <<EOF
ucr solution delete <solution id>
  Deletes a solution
EOF
}
function ucr_solution_delete {
  # ucr solution delete <solution id>
  want_envs UCR_API_URL "$ucr_api_url_pattern"
  local sid=${1:?Need solution id}
  v_curl -s ${UCR_API_URL}/solution/$sid \
    -X DELETE
}

####################
# Service Config

function ucr_help_services {
  cat <<EOF
ucr services
  List all services in a solution
EOF
}
function ucr_services {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig \
    -H 'Content-Type: application/json'
}

function ucr_help_service_usage {
  cat <<EOF
ucr service usage <service>
  Get usage information about a service
EOF
}
function ucr_service_usage {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig/${(L)service}/info
}

function ucr_help_service_details {
  cat <<EOF
ucr service details <service>
  Get details about a service
EOF
}
function ucr_service_details {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig/${(L)service}
}

function ucr_help_service_add {
  cat <<EOF
ucr service add <service>
  Add a service to the solution.
  The <service> can be the name of an IoT Connector to link, or a service name.
EOF
}
function ucr_service_add {
  # ucr service add <service>
  # Note, that the <service> can be the name of an IoT Connector to link
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  local req=$(jq -n -c --arg service "${(L)service}" --arg sid "$UCR_SID" '{"solution_id": $sid, "service": $service}')
  # erm.  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig/${(L)service} \
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig \
    -H 'Content-Type: application/json' \
    -d "$req"
}

function ucr_help_service_delete {
  cat <<EOF
ucr service delete <service>
  Delete a service from a solution
  Note, that the <service> can be the name of an IoT Connector to unlink
EOF
}
function ucr_service_delete {
  # ucr service delete <service>
  # Note, that the <service> can be the name of an IoT Connector to unlink
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/serviceconfig/${(L)service} \
    -H 'Content-Type: application/json' \
    -X DELETE
}

####################
# Service 

function ucr_help_service_schema {
  cat <<EOF
ucr service schema <service>
  Get the OpenAPI schema for a service
EOF
}
function ucr_service_schema {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/service/${(L)service}/schema
}

function ucr_help_service_installed {
  cat <<EOF
ucr service installed [<options>]
  List all services installed.
  These are the services that can be added to a solution.
  Options:
    --limit=<n>        Limit the number of results
    --offset=<n>       Offset the results by n
    --alias=<string>   Filter by alias (regex)
    --status=<list>    Comma separated list of statuses to filter by (available, hidden, removed, draft)
    --tags=<list>      Comma separated list of tags to filter by
    --type=<list>      Comma separated list of types to filter by (C, X, E, P, S)
EOF
}
function ucr_service_installed {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*" \
    offset "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4
  local opt_query=$(
    options_to_json \
    alias::string "^.*$" \
    status::array "^(available|hidden|removed|draft)(,(available|hidden|removed|draft))*$" \
    tags::array "^[a-zA-Z0-9_-]+(,[a-zA-Z0-9_-]+)*$" \
    type::array "^[CXEPS](,[CXEPS])*$"
  )
  [[ -z "$opt_query" ]] && exit 4

  # opt_req is an object, opt_query needs to be added to it as the 'query' key with its value as a @uri string
  local q=$(jq -r --argjson q "$opt_query" '( . + (if ($q | length) > 0 then {"query":($q|@uri)} else {} end)) | to_entries | map("\(.key)=\(.value)") | join("&")' <<< $opt_req)

  v_curl -s ${UCR_API_URL}/service\?${q}
}

####################

function ucr_help_template_update {
  cat <<EOF
ucr template update [<github repo url>]
  Request a solution to update to the project on Github.
  If url omitted, then will try to build one from current directory git remote
EOF
}
function ucr_template_update {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local repo_url
  if [[ $# > 0 ]]; then
    repo_url=$1
  else
    repo_url=https://github.com/${${$(git remote get-url origin)#git@github.com:}%%.git}
    repo_url+="/tree/$(git rev-parse --abbrev-ref HEAD)"
  fi
  local req=$(jq -n -c --arg url "$repo_url" '{"url": $url}')
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/update \
    -H 'Content-Type: application/json' \
    -d "$req"
}

function ucr_help_logs {
  cat <<EOF
ucr logs [--limit=] [--offset=]
  Get solution logs
EOF
}
function ucr_logs {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*" \
    offset "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4

  local q=$(jq -r 'to_entries|map("\(.key)=\(.value)")|join("&")' <<< $opt_req)

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/logs\?${q}
}

####################
# BizApi functions

function ucr_help_business_token {
  cat <<EOF
ucr business token
  Get a business token for the business in UCR_BID.
  Requires UCR_BIZ_URL and UCR_BID to be set.
  Requires UCR_USER and UCR_PASSWORD to be set for authentication.
  If either are prefixed with 'op:', then 1Password will be used to get the actual values.

  All other business tasks require this token to operate and automatically call this.
EOF
}
function ucr_business_token {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token
  echo "$UCR_TOKEN"
}

function ucr_help_business_solutions {
  cat <<EOF
ucr business solutions
  List all solutions for the business 
EOF
}
function ucr_business_solutions {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}/solution/" \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

function ucr_help_business_solution_delete {
  cat <<EOF
ucr business solution delete <solution id>
  Deletes a solution from a business
EOF
}
function ucr_business_solution_delete {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  local sid=${1:?Need solution id}
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}/solution/${sid}" -X DELETE \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

function ucr_help_business_solution_get {
  cat <<EOF
ucr business solution get <solution id>
  Gets solution info from a business
EOF
}
function ucr_business_get {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}" \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

#########################################################################

function ucr_help_sc {
  cat <<EOF
ucr sc <service> [--listops] [--no-cache] [--in=FILE] <operation> [--listparams] [options]
  Call a service operation.
  Use --listops to list the operations for the service.
  Use --listparams to list the parameters for the operation.
  Use --no-cache to force fetching the operations from the API.
  Use --in=FILE to read parameters from a JSON file instead of command line options.
  If FILE is '-', read from STDIN.

  Options are mapped to parameters by name, and validated against the parameter pattern if provided.
  All parameters are passed as options, none are positional.

  Note: This is a generic interface, and does not provide any special handling for specific services or operations.
EOF
}
function ucr_sc {
  # ucr sc <service> [--listops] [--no-cache] [--in=FILE] <operation> [--listparams] [options]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_DIS_URL "$ucr_dis_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local service=${1:?Need service name}

  # Check cache for service operations, if missing or older than a week, fetch new.
  # If --no-cache, always fetch new.
  local cache_file="${XDG_CACHE_HOME:-$HOME/.cache}/ucr/${service}-operations.json"
  mkdir -p ${cache_file:h}
  # If it doesn't exist, cache is false
  [[ -f $cache_file ]] || ucr_opts[cache]=false
  # If it exists, then check the age (this will set ucr_opts[cache] to false if too old)
  [[ -f $cache_file && -z "${cache_file}(N,md-7)" ]] && ucr_opts[cache]=false
  if [[ ${ucr_opts[cache]} == "false" ]]; then
    v_curl -s ${UCR_API_URL}/service/${(L)service} \
      | jq .operations > $cache_file
  fi

  # --listops will just list the operations for the service
  if [[ -n "$ucr_opts[listops]" ]]; then
    jq -r 'keys[]' $cache_file
    return
  fi

  local operation=${2:?Need operation name}
  shift 2
  # Get the operation details
  local operation_details=$(jq --arg op "$operation" '.[$op]' $cache_file)
  if [[ -z "$operation_details" || "$operation_details" == "null" ]]; then
    echo "Operation `$operation` not found for service $service" >&2
    exit 3
  fi

	# Want to map some parameters to options, and some to keys, and some to positional
  # For now, all are options. (not sure of a good generic way to decide which should be positional)
  # Only doing minimal validation here, since pegapi will do full.
  # Now, while this is very OpenAPI like, pegasus calling squashes all the parameters into a single object.
  # So we only need to look at the first item in parameters. It will be an object, whose keys are the parameters.
  # _sigh_; if one of these has a `x-exosite-from` in its value, then we need to use that for the key instead of the original key.
  local opt_req='{}'
  if [[ $(jq '.parameters|length' <<< $operation_details) > 0 ]]; then
    local param_patterns=($(jq -r '.parameters[0].properties | to_entries[] |
    	.value.type |= if (.|type) == "array" then
        "object"
      else
        .
      end |
      .rex = if (.value|has("pattern")) then
        .value.pattern
      elif (.value | has("enum")) then
        "^(" + (.value.enum|join("|")) + ")$"
      elif .value.type == "string" then
        "^.*$"
      elif .value.type == "integer" then
        "^[0-9]+$"
      elif .value.type == "number" then
        "^[0-9]+(\\.[0-9]+)?$"
      elif .value.type == "boolean" then
        "^(true|1|yes|ok|y|t|false|no|n|f)$"
      else
        "^.*$"
      end |
      "\(if (.value | has("x-exosite-from")) then .value."x-exosite-from" else .key end)::\(.value.type)", "\(.rex)"' <<< $operation_details))
    # echo "= = $param_patterns" >&2
    [[ -n "$param_patterns" ]] && opt_req=$( options_to_json "${(@)param_patterns}")
    [[ -z "$opt_req" ]] && exit 4
  fi

  # --listparams will just list the paramaters for the operation
  if [[ -n "$ucr_opts[listparams]" ]]; then
    if [[ $(jq '.parameters|length' <<< $operation_details) > 0 ]]; then
      for (( i=1; i<=$#param_patterns; i+=2 )); do
        local key=${param_patterns[i]%%::*}
        local type=${param_patterns[i]#*::}
        local rex=${param_patterns[i+1]}
        echo " --$key=<${type} by $rex>"
      done
      return
    else
      echo "No parameters for operation $operation" >&2
      return
    fi
  fi

  if [[ -n "${ucr_opts[in]}" ]]; then
    local file=${ucr_opts[in]}
    # If --in is `-`, use STDIN
    [[ "$file" == "-" ]] && file=/dev/stdin
    # Merge with opt_req
    opt_req=$(jq --argjson opt "$opt_req" '. * $opt' $file)
  fi

  _dis_call "${(L)service}" "${operation}" "$opt_req"
}

function _dis_call {
  want_envs UCR_DIS_URL "$ucr_dis_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Internal function to call the dispatcher
  local service=$1
  local operation=$2
  local data="$3"

  local ecf=$(mktemp -t discall.ecf.XXXXXX)

  local res=$(v_curl -s ${UCR_DIS_URL}/call/${UCR_SID}/${(L)service}/${operation}\?noWrap\=true \
    --write-out "%output{>>${ecf}}%{http_code},%{content_type}" \
    -H 'Content-Type: application/json' \
    -d "$data" 
  )

  local ec content_type
  IFS=',' read -r ec content_type < $ecf
  if [[ -n "${ucr_opts[debug]}" ]]; then
    echo "Status: $ec Type: $content_type" >&2
  fi
  # while _technically_ dispatcher should only ever return application/json, reality is not so kind.
  if [[ -n "${ucr_opts[raw]}" ]]; then
    content_type="application/octet-stream"
  elif [[ -n "${ucr_opts[contenttype]}" ]]; then
    content_type=${ucr_opts[contenttype]}
  elif [[ -z "$content_type" ]]; then
    content_type="application/octet-stream"
  else
    content_type=${content_type%%;*} # strip any charset or other params
  fi

  ec=$((ec))
  rm -f $ecf
  if [[ $ec > 400 ]]; then
    echo "Error calling ${(L)service}.${operation} [${ec}]:" >&2
  fi

  if [[ $content_type == "application/json" ]]; then
    jq  <<< "$res"
  else
    print "$res"
  fi
}

#########################################################################
# Below are Service specific abstractions

####################
# TSDB service

function ucr_help_tsdb_query {
  cat <<EOF
ucr tsdb query [<options>] <metric>… [<tag name>@<tag value>…]
  Query time series data.
  Metric names are just args, tags are <tag name>@<tag value>
EOF
if [[ -z "${ucr_opts[short]}" ]]; then
  cat <<EOF
  Options:
    --start_time=<time>        Start time for the query.
                               (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --end_time=<time>          End time for the query.
                               (e.g. 1633123200000ms or 1633123200s or RFC3339 UTC string)
    --relative_start=<time>    Relative start time for the query. (e.g. -1d, -12h, -30m)
    --relative_end=<time>      Relative end time for the query. (e.g. -1d, -12h, -30m)
    --sampling_size=<time>     Sampling size for downsampling. (e.g. 1m, 5m, 1h)
    --limit=<number>           Limit the number of data points returned.
    --epoch=(u|ms|s)           Return timestamps in microseconds, milliseconds, or seconds.
                               Defaults to RFC3339 UTC.
    --mode=(merge|split)       Merge all metrics into a single time series, or split into multiple
                               series by tag combinations. Default is merge.
    --fill=(null|previous|none|<number>|~s:.+) 
                               Fill missing data points with null, previous value, no fill, a
                               specific number, or a string.  Only in mode=merge.
    --order_by=(desc|asc)      Order results by timestamp descending or ascending. Default is desc.
    --aggregate=(avg|min|max|count|sum),+ 
                               Aggregate data points using the specified functions.
                               Can specify multiple functions separated by commas.
                               Note: aggregate requires sampling_size to be set.
EOF
  fi
}
function ucr_tsdb_query {
  # metric names are just args, tags are <tag name>@<tag value>
  # others are all --options=value
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Validate a list of the options we will care about.
  local opt_req=$(
    options_to_json \
    start_time "[0-9]*(u|ms|s)?" \
    end_time "[1-9][0-9]*(u|ms|s)?" \
    relative_start "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    relative_end "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    sampling_size "[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    limit "[1-9][0-9]*" \
    epoch "(u|ms|s)" \
    mode "(merge|split)" \
    fill "(null|previous|none|[1-9][0-9]*|~s:.+)" \
    order_by "(desc|asc)" \
    aggregate "((avg|min|max|count|sum),?)+"
  )
  [[ -z "$opt_req" ]] && exit 4

  local req=$(jq -c '. + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    {
      "tags": map(select(.value)) | group_by(.key) | map({"key":.[0].key,"value":(map(.value) | if length==1 then first else . end)}) | from_entries,
      "metrics": map(select(.value | not) | .key)
    })' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb query "$req"
}

function ucr_help_tsdb_recent {
  cat <<EOF
ucr tsdb recent <tag name> <metrics>… [<tag name>@<tag values>…]
  Get the most recent data points for the given metrics and tag values.
  Metric names are just args, tags are <tag name>@<tag value>
EOF
}
function ucr_tsdb_recent {
  # recent <tag name> <metrics>… @<tag values>… 
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local tag_name=${1:?Need tag name}
  shift
  [[ $# == 0 ]] && echo "Missing metrics and tag values" >&2 && exit 2

  local req=$(jq -n -c --arg tn "${tag_name}" '{
    "metrics": ($ARGS.positional | map(select(. | startswith("@") | not))),
    "tag_name": $tn,
    "tag_values": ($ARGS.positional | map(select(. | startswith("@"))) | map(split("@") | .[1] )),  
  }' --args -- "${@}")

  _dis_call tsdb recent "$req"
}

function ucr_help_tsdb_list_tags {
  cat <<EOF
ucr tsdb list tags
  List all tag names.
EOF
}
function ucr_tsdb_list_tags {
  _dis_call tsdb listTags '' | jq '.tags | keys'
}

function ucr_help_tsdb_list_metrics {
  cat <<EOF
ucr tsdb list metrics
  List all metric names.
EOF
}
function ucr_tsdb_list_metrics {
  _dis_call tsdb listMetrics '' | jq .metrics
  # someday: Look for .next, and handle repeated calls if need be
}

function ucr_help_tsdb_exports {
  cat <<EOF
ucr tsdb exports
  List all export jobs.
EOF
}
function ucr_tsdb_exports {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4

  _dis_call tsdb exportJobList "$opt_req" 
}

function ucr_help_tsdb_export_info {
  cat <<EOF
ucr tsdb export_info <job id>
  Get information about a specific export job.
EOF
}
function ucr_tsdb_export_info {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local job_id=${1:?Need job id argument}

  _dis_call tsdb exportJobInfo "{\"job_id\":\"${job_id}\"}"
}

function ucr_help_tsdb_export {
  cat <<EOF
ucr tsdb export [<options>] <metric>… [<tag name>@<tag value>…] [<formatting>…]
  Export time series data to a CSV file.
EOF
if [[ -z "${ucr_opts[short]}" ]]; then
  cat <<EOF
  Metric names are just args, tags are <tag name>@<tag value>, formats are <metric>#<action>#<value>
  Options:
    --output=<filename>      Output file name. Defaults to <timestamp>_auto.csv
    --start_time=<time>      Start time for the query.
                             (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --end_time=<time>        End time for the query.
                             (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --relative_start=<time>  Relative start time for the query.  (e.g. -1h)
    --relative_end=<time>    Relative end time for the query.  (e.g. -1h)
    --limit=<number>         Limit the number of results.  (e.g. 100)
    --epoch=<unit>           Epoch time unit.  (e.g. s, ms, us) Defaults to RFC3339 UTC.
    --fill=<method>          Fill method for missing data. (e.g. previous, null)
    --order_by=<field>       Order results by a specific field. (e.g. timestamp)

    --timestamp=<time format>
                             Apply a datetime format to the timestamp column.
                             (e.g. %Y-%m-%dT%H:%M:%S.%f%z)
    --offset=<hours>         Offset to apply to the timestamp. (e.g. -4 for EDT)
    --include=<tags>         Comma-separated list of which tags to include in the export.
                             (e.g. tag1,tag2)
                             Default is to exclude all tags.

  Formatting:
    ORDER MATTERS! FE: round before label is different than label before round
    
    <metric>#label#<string>
    3456789#label#foo
      Prefix value with 'foo'
    
    <metric>#round#<number>
    3456789#round#9
      Round by 9
    
    <metric>#rename#<string>
    34567890#rename#bob
      Replace metric name with 'bob'
    
    <metric>#replace#<regexp>#<replace>
    123456#replace#([0-9])([0-9])#\2-\1
      Do regexp on value. replace uses '\1' for capture groups.
    
    <metric>|timestamp#datetime#<date format>#<offset>
    98765#datetime#year_%Y#-4
      Apply a datetime format to the value. Value should be microseconds since the EPOCH.
      Can use the '--timestamp' and '--offset' to shortcut for the 'timestamp' column.
EOF
  fi
}
function ucr_tsdb_export {
  # metric names are just args, tags are <tag name>@<tag value>, formats are <metric>#<action>#<value>
  #
  # Formating parameters:
  # ORDER MATTERS! FE: round before label is different than label before round
  #
  # <metric>#label#<string>
  # 3456789#label#foo
  #   Prefix value with 'foo'
  #
  # <metric>#round#<number>
  # 3456789#round#9
  #   Round by 9
  #
  # <metric>#rename#<string>
  # 34567890#rename#bob
  #   Replace metric name with 'bob'
  #
  # <metric>#replace#<regexp>#<replace>
  # 123456#replace#([0-9])([0-9])#\2-\1
  #   Do regexp on value. replace uses '\1' for capture groups.
  #
  # <metric>|timestamp#datetime#<date format>#<offset>
  # 98765#datetime#year_%Y#-4
  #   Apply a datetime format to the value. Value should be microseconds since the EPOCH.
  #   Can use the `--timestamp` and `--offset` to shortcut for the `timestamp` column.

  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Validate a list of the options we will care about.
  # Ignored query options: (passing them does nothing)
  #  mode "(merge|split)"
  # Illegal query options: (passing them returns error)
  #  sampling_size "[1-9][0-9]*(u|ms|s|m|h|d|w)?"
  #  aggregate "((avg|min|max|count|sum),?)+" 
  local opt_req=$(
    options_to_json \
    start_time "[1-9][0-9]*(u|ms|s)?" \
    end_time "[1-9][0-9]*(u|ms|s)?" \
    relative_start "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    relative_end "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    limit "[1-9][0-9]*" \
    epoch "(u|ms|s)" \
    fill "(null|previous|none|[1-9][0-9]*|~s:.+)" \
    order_by "(desc|asc)"
  )
  [[ -z "$opt_req" ]] && exit 4

  # A few filtering only options.
  # These are all just once things, so it is cleaner to have them as options than as the '#' syntax
  local formated=$(
    options_to_json \
    timestamp ".*"\
    offset "-?[1-9][0-9]*" \
    include "[a-zA-Z0-9_,]+"
  )
  [[ -z "$formated" ]] && exit 4

  local filename=${ucr_opts[output]}
  if [[ -z "$filename" ]]; then
    filename="$(date +%s)_auto.csv"
  fi
  # if [[ "$filename" =~ "[\r\n\t\f\v ]" ]]; then
  #   echo "output file name cannot have spaces ($filename)" >&2
  #   exit 5
  # fi


  local req=$(jq --arg fn "$filename" --argjson ft "$formated" '{
    "query": (. + ($ARGS.positional | {
      "tags": ([.[] | select(contains("@")) | split("@") | {"key": .[0], "value": .[1]}] | group_by(.key) |
        map({"key":.[0].key,"value":(map(.value) | if length==1 then first else . end)}) | from_entries),
      "metrics": [.[]|select(contains("@") or contains("#")|not)]
    })),
    "filename": $fn,
    "format": (($ARGS.positional | [.[] | select(contains("#")) | split("#") | {
        "metric": .[0], "fn": .[1], "a": .[2], "b": .[3]
      }] | group_by(.metric) | map({"key":.[0].metric, "value": map(
        if .fn == "round" then {"round": .a|tonumber}
        elif .fn == "replace" then {replace: { match: .a, to: .b } }
        elif .fn == "datetime" then {datetime: { dt_format: (.a // "%Y-%m-%dT%H:%M:%S.%f%z"), offset: (.b // 0 | tonumber) }}
        else { (.fn): .a }
        end
      )}) | from_entries ) + if ($ft|has("timestamp") or has("offset")) then
        { "timestamp": [{datetime:{dt_format: ($ft.timestamp // "%Y-%m-%dT%H:%M:%S.%f%z"), offset: ($ft.offset // 0 | tonumber)}}] }
      else
        {}
      end + if ($ft|has("include")) then
        {"tags": [{normalize: $ft.include|split(",")}]}
      else
        {tags: [{discard: true}]}
      end
    )
  }' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb export "$req"
}

function ucr_help_tsdb_write {
  cat <<EOF
ucr tsdb write [--ts=<timestamp>] <metric> <value> [<metric> <value> …] [<tag>@<value> …]
  Write time series data points.
  Metric names and values are pairs of args, tags are <tag name>@<tag value>
EOF
}
function ucr_tsdb_write {
  # write [--ts=<timestamp>] <metric> <value> [<metric> <value> …] [<tag>@<value> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local opt_req=$(options_to_json ts "[1-9][0-9]*(u|ms|s)?") # ??? does ts take suffixes?
  [[ -z "$opt_req" ]] && exit 4

  local req=$(jq -c 'def nwise($n): while(.!=[]; .[$n:])[:$n]; . + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    { "tags": (map(select(.value)) | from_entries),
      "metrics": ([map(select(.value|not)|.key) | nwise(2) | {"key": .[0], "value": .[1]}] | from_entries)
    })' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb write "$req"
}

####################
# Keystore service

function ucr_help_keystore_list {
  cat <<EOF
ucr keystore list [<match>]
  List keys in the keystore. Optionally filter by match pattern (default '*')
EOF
}
function ucr_keystore_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local match=${1:-*}
  local req=$(jq -n -c --arg match "$match" '{"match":$match,"cursor":0}')

  _dis_call keystore list "$req"
}

function ucr_help_keystore_get {
  cat <<EOF
ucr keystore get <key> [<key> …]
  Get one or more keys from the keystore.
EOF
}
function ucr_keystore_get {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  [[ $# == 0 ]] && echo "Missing keys to get" >&2 && exit 2
  local req=$(jq -n -c '{"keys":$ARGS.positional}' --args -- "${@}")

  _dis_call keystore mget "$req"
}

function ucr_help_keystore_set {
  cat <<EOF
ucr keystore set <key> <value>
  Set a key in the keystore. Use '-' as value to read from STDIN.
  (atm there is no way to set a value of '-')
EOF
}
function ucr_keystore_set {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local key=${1:?Need key argument}
  local value=${2:?Need value to set}
  if [[ "$value" = "-" ]]; then
    value=$(</dev/stdin)
  fi

  local req=$(jq -n -c --arg key "$key" --arg value "$value" '{"key":$key,"value":$value}')

  _dis_call keystore set "$req"
}

function ucr_help_keystore_delete {
  cat <<EOF
ucr keystore delete <key> [<key> …]
  Delete one or more keys from the keystore.
EOF
}
function ucr_keystore_delete {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  [[ $# == 0 ]] && echo "Missing keys to delete" >&2 && exit 2
  local req=$(jq -n -c '{"keys":$ARGS.positional}' --args -- "${@}")

  _dis_call keystore mdelete "$req"
}

function ucr_help_keystore_cmd {
  cat <<EOF
ucr keystore cmd <key> <command> [<arg> …]
  Execute a command on a key in the keystore.
EOF
}
function ucr_keystore_cmd {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cmd=${1:?Need command argument}
  local key=${2:?Need key argument}
  shift 2
  local req=$(jq -n -c --arg key "$key" --arg cmd "$cmd" \
    '{"key":$key,"command":$cmd, "args": $ARGS.positional}' \
    --args -- "${@}")

  _dis_call keystore command "$req"
}


####################

function ucr_help_content_info {
  cat <<EOF
ucr content info <content id>
  Returns information about the specified content.
EOF
}
function ucr_content_info {
  local id=${1:?Need file id}
  local req="{\"id\": \"$id\"}"

	_dis_call content info "$req"
}

function ucr_help_content_list {
  cat <<EOF
ucr content list [--op=AND|OR] [--stop=#] [<prefix filter>] [<tag name filter>@<tag value filter> ...]
  Lists content matching the specified filters.
  --op determines if multiple tag filters are ANDed or ORed. Default is AND.
  --stop limits the number of results returned. Default is no limit.
EOF
}
function ucr_content_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # list [--op=AND|OR] [--stop=#] [<prefix filter>] [<tag name filter>@<tag value filter> ...]
  local opt_req=$(options_to_json \
    op "^(AND|OR)$" 
  )
  [[ -z "$opt_req" ]] && exit 4

  local p_req=$(jq -c '. + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    {
      "tags": (map(select(.value)) | from_entries | tojson),
      "prefix": (map(select(.value|not)|.key) | first),
      "full": true
    } | del(.[] | select(. == null)))' --args -- "${@}" <<< $opt_req)

  local prior_count=1
  local total_count=0
  local stop_after=${ucr_opts[stop]:-999999999}
  local cursor=''

  # first call always happens and has no cursor.
  local ret=$( _dis_call content list "$p_req")
  prior_count=$(jq -r length <<< $ret)
  total_count=$(( total_count + prior_count ))
  cursor=$(jq -r 'last | .id' <<< $ret)
  # Now 'stream' results
  jq -c -M '.[]' <<< $ret

  # Loop advancing cursor until an empty reply
  while [[ prior_count -gt 0 && total_count -lt stop_after ]]; do
    local req=$(jq -c --arg cursor "$cursor" '. + {"cursor": $cursor}' <<< $p_req)
    local ret=$(_dis_call content list "$req")
    prior_count=$(jq -r length <<< $ret)
    total_count=$(( total_count + prior_count ))
    cursor=$(jq -r 'last | .id' <<< $ret)
    # Now 'stream' results
    jq -c -M '.[]' <<< $ret
  done
}

function ucr_help_content_delete {
  cat <<EOF
ucr content delete <content id> [<content id> ...]
  Deletes the specified content.
EOF
}
function ucr_content_delete {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local req=$(jq -n -c '{ "body" : $ARGS.positional }' --args -- "$@")

  _dis_call content deleteMulti "$req"
}

function ucr_help_content_download {
  cat <<EOF
ucr content download <content id> [--expires_in=<seconds>]
  Returns a URL to download content from.
  --expires_in determines how long the URL is valid for.
EOF
}
function ucr_content_download {
  # doesn't actually download, just returns a URL to download from.
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cid=${1:?Need content id to download}
  local opt_req=$(options_to_json \
    expires_in "^\d+$" \
  )
  [[ -z "$opt_req" ]] && exit 4
  local req=$(jq -c --arg cid "$cid" '. + {"id": $cid|@uri }' <<< $opt_req)

  _dis_call content download "$req"
}

function ucr_help_content_upload {
  cat <<EOF
ucr content upload <content id> [--expires_in=<seconds>] [--type=<mime type>]
  Returns a curl command line to upload content to.
  --expires_in determines how long the URL is valid for.
EOF
}
function ucr_content_upload {
  # Doesn't actually upload, just returns a cURL to upload to.
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cid=${1:?Need content id to upload}
  local opt_req=$(options_to_json \
    expires_in "^\d+$" \
    type "^.+$" \
  )
  [[ -z "$opt_req" ]] && exit 4

  # A GET req with url encoded file name and query options for the rest.
  local req=$(jq -n -c --arg cid "$cid" '{"id": $cid|@uri }')
  local psu=$(_dis_call content upload "$req")

  # Convert to new curl params
  local params=($(jq '(.inputs|to_entries|[.[]|"-F", "\"\(.key)=\(.value)\""]) + (["-F", "\"\(.field)=@\(.id)\"", .url]) |.[]' -r <<< $psu))
  echo curl -X POST "${params[@]}"
}

##################################################

function ucr_help_device_add {
  cat <<EOF
ucr device add <did>
  Adds a device to the allowlist.
  "ucr device activate" must be called afterwards to be able to write to it.
EOF
}
function ucr_device_add {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local did=${1:?Need device id}
  local req=$(jq -c -n --arg did "$did" '{"identity": $did, locked: false}')
  _dis_call device2 addIdentity "$req"
}

function ucr_help_device_list {
  cat <<EOF
ucr device list
  Lists all devices.
EOF
}
function ucr_device_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  _dis_call device2 listIdentities ""
}

function ucr_help_device_info {
  cat <<EOF
ucr device info <did>
  Displays information about device service
EOF
}
function ucr_device_info {
  ucr_service_details device2
}

function ucr_help_device_state {
  cat <<EOF
ucr device state <did>
  Displays the current state of a device.
  This includes the set and reported values for resources.
EOF
}
function ucr_device_state {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local did=${1:?Need device id}
  local req=$(jq -c -n --arg did "$did" '{"identity": $did}')
  _dis_call device2 getIdentityState "$req"
}

# This sets via the cloud side API.
# function ucr_device_state_set { }

function ucr_help_device_write {
  cat <<EOF
ucr device write <did> <resource> <value>
  Records a resource value via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_write {
  # This writes via the external HTTP API.
  # Only one resource at a time for now. Could expand to allow multiple, but not needed today.
  # ucr device write <did> <resource> <value>
  local did=${1:?Need device id}
  local res=${2:?Need a resource to write}
  local val=${3:?Need a value}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)
  local vm=$(jq -r .solution_id <<< $details)
  local cik=$UCR_CIK
  # if UCR_CIK_<did> is set, use that instead
  local cik_var="UCR_CIK_${did}"
  if [[ -n "${(P)${cik_var}}" ]]; then
    cik=${(P)${cik_var}}
  fi

  # server actually only supports a subset of form-urlencoded, so manually pack it
  val=$(jq -r '@uri' <<< $val)
  v_curl -s https://${d_host}/onep:v1/stack/alias \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8' \
    -H "X-Exosite-CIK: ${cik}" \
    -d "${res}=${val}"
}

function ucr_help_device_record {
  cat <<EOF
ucr device record <did> <resource> <ts> <value>
  Records a resource value via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_record {
  # This writes via the external HTTP API.
  # Only one resource at a time for now. Could expand to allow multiple, but not needed today.
  # ucr device record <did> <resource> <ts> <value>
  local did=${1:?Need device id}
  local res=${2:?Need a resource to write}
  local ts=${3:?Need a timestamp}
  local val=${4:?Need a value}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)
  local vm=$(jq -r .solution_id <<< $details)
  local cik=$UCR_CIK
  # if UCR_CIK_<did> is set, use that instead
  local cik_var="UCR_CIK_${did}"
  if [[ -n "${(P)${cik_var}}" ]]; then
    cik=${(P)${cik_var}}
  fi

  # server actually only supports a subset of form-urlencoded, so manually pack it
  val=$(jq -r '@uri' <<< $val)
  v_curl -s https://${d_host}/onep:v1/stack/record \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8' \
    -H "X-Exosite-CIK: ${cik}" \
    -d "alias=${res}&${ts}=${val}"
}

function ucr_help_device_exo_write {
  cat <<EOF
ucr device exo write <did> <channel> <value> [<channel> <value> ...]
  Writes channel values via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_exo_write {
  # ExoSense wraps channels into a data_in resource
  # ucr device exo write <did> <channel> <value> [<channel> <value> ...]
  # TODO: Add a way to set channel values as JSON
  local did=${1:?Need device id}
  [[ $# -lt 3 ]] && echo "Need at least 3 arguments" >&2 && exit 2
  shift
  # take args and turn into a JSON object
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n];. + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  ucr_device_write "$did" data_in "$req"
}

function ucr_help_device_exo_record {
  cat <<EOF
ucr device exo record <did> <ts> <channel> <value> [<channel> <value> ...]
  Records channel values via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_exo_record {
  # ExoSense wraps channels into a data_in resource
  # ucr device exo write <did> <ts> <channel> <value> [<channel> <value> ...]
  local did=${1:?Need device id}
  local ts=${2:?Need a timestamp}
  [[ $# -lt 4 ]] && echo "Need at least 4 arguments" >&2 && exit 2
  shift 2
  # take args and turn into a JSON object
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n];. + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  ucr_device_record "$did" data_in "$ts" "$req"
}

function ucr_help_device_confirm {
  cat <<EOF
ucr device confirm <did> [<resource>]
  Confirms the set value of a resource by reporting it.
  The device must be active for this to work.

  <resource> defaults to 'config_io'
EOF
}
function ucr_device_confirm {
  local did=${1:?Need device id}
  local rid=${2:-config_io}

  local state=$(ucr_device_state "$did" | jq -r --arg rid "$rid" '.[$rid].set')
  ucr_device_write "$did" "$rid" "$state"
}

function ucr_help_device_activate {
  cat <<EOF
ucr device activate <did>
  Activates a device via the external HTTP API.
EOF
}
function ucr_device_activate {
  # This activates via the external HTTP API.
  local did=${1:?Need device id}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)

  # server actually only supports a subset of form-urlencoded, so manually pack it
  # did=$(jq -r '@uri' <<< $did)
  v_curl -s https://${d_host}/provision/activate \
    -d "id=${did}" \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8'
}

##############################################################################
# Finally, run the task runner to find and run the task based on arguments
task_runner "$@"
