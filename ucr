#!/usr/bin/env zsh
# A cli to Murano solutions, for both cloud and on-prem

##############################################################################
# Set the script name, ulcer-core uses this to find functions and setup the environment
argv0=${${0:t}:r}

# Load the ulcer-core.zsh
ulcer_core=$(whence -p ulcer-core.zsh)
if [[ -n $ulcer_core ]]; then
	source $ulcer_core
else
	echo "Error: ulcer-core.zsh not found"
	exit 1
fi

##############################################################################
# Define some helper functions

# Get a murano login token and save it in env to use by following commands.
# Just smart enough not to call more than once per evocation, could save token somewhere for multiple.
# Not worth the extra work.
function get_token {
  if [[ -z "$UCR_TOKEN" ]]; then
    # echo "X: $psd" >&2
    # Murano doesn't accept basic auth…
    local req=""
    if [[ "$UCR_USER" =~ '^op:' || "$UCR_PASSWORD" =~ '^op:' ]] && (which op >/dev/null); then
      # They have 1password and are using it, so op run
      req=$(op run --no-masking -- jq -n '{"email": $ENV.UCR_USER, "password": $ENV.UCR_PASSWORD}')
    else
      echo "Only 1password is supported anymore." >&2
      exit 2
    fi
    # echo "X: $req" >&2
    export UCR_TOKEN=$(curl -s https://${UCR_BIZ_URL}/token/ -H 'Content-Type: application/json' -d "$req" | jq -r .token)
  fi
}

# Repeating this in every command gets messy; so we'll do it once here.
# all the same for now
ucr_api_url_pattern="^https?://[\.A-Za-z0-9:-]+"
ucr_dis_url_pattern="^https?://[\.A-Za-z0-9:-]+"
ucr_biz_url_pattern="^https?://[\.A-Za-z0-9:-]+"

##############################################################################
# Define the tasks for this tool

function ucr_help {
  cat <<EOF
ucr <task> [<args…>] [--opts…] [KEY=VALUE…]
  CLI to the guts of Murano; if you know, then you know. Otherwise not for you.

  'ucr help <task>' or 'ucr <task> --help' for more info on a specific task.
  'ucr tasks [<prefix filter>]' to see what tasks are implemented.
  'ucr state' to check ENVs, ARGs, and options.

  Options, key-values, and arguments can be interwoven as make sense.

  Key-Values:
    These get prefixed with UCR_, upcased, and then become environment variables.

  Environment variables:
    UCR_SID       Solution Identifier
    UCR_BID       Business Identifier
    UCR_API_URL   URL to API endpoint
    UCR_DIS_URL   URL to call runner
    UCR_BIZ_URL   URL to call business logic
EOF
}


function ucr_help_dump_script {
  cat <<EOF
ucr dump script
  Dump out the unified Lua script for a solution

  Useful to see what extra junk was actually added.
EOF
}
function ucr_dump_script {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID}/script \
    -H 'Content-Type: application/json'
}

function ucr_help_dump_source_map {
  cat <<EOF
ucr dump source map
  Dump out a map of the Lua fragments to line numbers of the unified solution script
EOF
}
function ucr_dump_source_map {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID}/sourcemap \
    -H 'Content-Type: application/json'
}

function ucr_help_flow {
  cat <<EOF
ucr flow
  Get the data-flow config for a solution
EOF
}
function ucr_flow {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/route/${UCR_SID} \
    -H 'Content-Type: application/json' \
    | jq '.flow'
}

function ucr_help_flow_set {
  cat <<EOF
ucr flow set < flow_file
  Set the data-flow config for a solution.
  The flow_file should be a JSON object representing the flow.
  To update a flow use: ucr flow | jq <stuff> | ucr flow set
EOF
}
function ucr_flow_set {
  # ucr flow set < flow_file
  # or: ucr flow | jq <stuff> | ucr flow set
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local req=$(jq -c '{"flow": .}')
  v_curl -s ${UCR_API_URL}/route/${UCR_SID} \
    -H 'Content-Type: application/json' \
    -X PUT \
    -d "$req"
}

function ucr_help_env_get {
  cat <<EOF
ucr env get
  Get all solution environment variables for the solution.
EOF
}
function ucr_env_get {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json'
}

function ucr_help_env_set {
  cat <<EOF
ucr env set <key> <value> [<key <value> …] [--overwrite]
  Set one or more solution environment variables for the solution.
  By default, adds or updates keys.
  Use --overwrite to replace all prior keys with the new set.
EOF
}
function ucr_env_set {
  # <key> <value> [<key <value> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local method=PUT
  if [[ -n "$ucr_opts[overwrite]" ]]; then
    method=POST
  fi

  # build values req
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n]; . + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json' \
    -X $method \
    -d "$req"
}

function ucr_help_env_del {
  cat <<EOF
ucr env del <key> [<key> …]
  Delete one or more solution environment variables from the solution.
EOF
}
function ucr_env_del {
  # <key> [<key> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  # req is an object with each key set to null
  local req=$(jq -n -c '. + ([$ARGS.positional[]|{"key":.,"value":null}]|from_entries)' --args -- "${@}")

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/env \
    -H 'Content-Type: application/json' \
    -X PUT \
    -d "$req"
}

function ucr_help_solution_info {
  cat <<EOF
ucr solution info <solution id>
  Get information about a solution
EOF
}
function ucr_solution_info {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}
}

function ucr_help_solution_list {
  cat <<EOF
ucr solution list [<options>]
  List all solutions
  Options:
    --business_id=<id>   Filter by business id
    --template=<type>    Filter by template type (application or m2connector)
EOF
}
function ucr_solution_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern"
  local filter='%7B%7D'
  local opt_req=$(
    options_to_json \
    business_id::string ".*" \
    template::string ".*"
  )
  [[ -n "$opt_req" ]] && filter=$(jq -n -c -r "$opt_req | @uri")
  v_curl -s ${UCR_API_URL}/solution\?query\=$filter \
    -H 'Content-Type: application/json'
}

function ucr_help_solution_create {
  cat <<EOF
ucr solution create SID=<solution id> [BID=<business id>] [--m2] [--file=<template name>] [--github=<url>] [--exchange=<ids>]
  Creates a new solution
EOF
}
function ucr_solution_create {
  # ucr solution create SID=<new id> [BID=<business id>] [--m2] [--file=<template name>] [--github=<url>] [--exchange=<ids>]
  want_envs UCR_API_URL "$ucr_api_url_pattern" \
    UCR_SID "^[a-zA-Z0-9]+$" \
    UCR_BID "^[a-zA-Z0-9]+$"
  local domain=${1:?Need domain}
  local type="application" # or m2connector
  if [[ -n "$ucr_opts[m2]" ]]; then
    type="m2connector"
  fi
  local template='{}'
  if [[ -n "$ucr_opts[file]" ]]; then
    template='{"source":{ "from": "file", "path": "/tmp/custom-solution-templates/'"$ucr_opts[file]"'"}}'
  fi
  if [[ -n "$ucr_opts[github]" ]]; then
    template='{"source":{ "from": "github", "url": "'"$ucr_opts[github]"'"}}'
  fi
  local exchangelist=''
  if [[ -n "$ucr_opts[exchange]" ]]; then
    exchangelist="X-exosite-exchange-id: $ucr_opts[exchange]"
  fi

  local req=$(jq -n -c --arg type "$type" --arg domain "$domain" --argjson template "$template" '{
				"name": $ENV.UCR_SID,
				"domain": $domain,
				"business_id": $ENV.UCR_BID,
				"template": $type,
				"services": [],
				"env": {},
			} + $template')

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID} \
    -H 'Content-Type: application/json' \
    -H "$exchangelist" \
    -d "$req"

}

function ucr_help_solution_delete {
  cat <<EOF
ucr solution delete <solution id>
  Deletes a solution
EOF
}
function ucr_solution_delete {
  # ucr solution delete <solution id>
  want_envs UCR_API_URL "$ucr_api_url_pattern"
  local sid=${1:?Need solution id}
  v_curl -s ${UCR_API_URL}/solution/$sid \
    -X DELETE
}

####################
# Service Config

function ucr_help_services {
  cat <<EOF
ucr services
  List all services in a solution
EOF
}
function ucr_services {
  # ??? add more optional query parameters?
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local q=$(jq -c -n -r '{"solution_id": $ENV.UCR_SID} | @uri')
  v_curl -s ${UCR_API_URL}/serviceconfig\?query=$q
}

function ucr_help_service_usage {
  cat <<EOF
ucr service usage <service>
  Get usage information about a service
EOF
}
function ucr_service_usage {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/serviceconfig/${UCR_SID}_${(L)service}/info
}

function ucr_help_service_details {
  cat <<EOF
ucr service details <service>
  Get details about a service
EOF
}
function ucr_service_details {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/serviceconfig/${UCR_SID}_${(L)service}
}

function ucr_help_service_add {
  cat <<EOF
ucr service add <service>
  Add a service to the solution.
  The <service> can be the name of an IoT Connector to link, or a service name.
EOF
}
function ucr_service_add {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  local req=$(jq -n -c --arg service "${(L)service}" --arg sid "$UCR_SID" '{"solution_id": $sid, "service": $service}')
  v_curl -s ${UCR_API_URL}/serviceconfig \
    -H 'Content-Type: application/json' \
    -d "$req"
}

function ucr_help_service_delete {
  cat <<EOF
ucr service delete <service>
  Delete a service from a solution
  Note, that the <service> can be the name of an IoT Connector to unlink
EOF
}
function ucr_service_delete {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/serviceconfig/${UCR_SID}_${(L)service} \
    -H 'Content-Type: application/json' \
    -X DELETE
}

####################
# Service 

function ucr_help_service_schema {
  cat <<EOF
ucr service schema <service>
  Get the OpenAPI schema for a service
EOF
}
function ucr_service_schema {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}
  v_curl -s ${UCR_API_URL}/service/${(L)service}/schema
}

function ucr_help_service_installed {
  cat <<EOF
ucr service installed [<options>]
  List all services installed.
  These are the services that can be added to a solution.
  Options:
    --limit=<n>        Limit the number of results
    --offset=<n>       Offset the results by n
    --alias=<string>   Filter by alias (regex)
    --status=<list>    Comma separated list of statuses to filter by (available, hidden, removed, draft)
    --tags=<list>      Comma separated list of tags to filter by
    --type=<list>      Comma separated list of types to filter by (C, X, E, P, S)
EOF
}
function ucr_service_installed {
  want_envs UCR_API_URL "$ucr_api_url_pattern"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*" \
    offset "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4
  local opt_query=$(
    options_to_json \
    alias::string "^.*$" \
    status::array "^(available|hidden|removed|draft)(,(available|hidden|removed|draft))*$" \
    tags::array "^[a-zA-Z0-9_-]+(,[a-zA-Z0-9_-]+)*$" \
    type::array "^[CXEPS](,[CXEPS])*$"
  )
  [[ -z "$opt_query" ]] && exit 4

  # opt_req is an object, opt_query needs to be added to it as the 'query' key with its value as a @uri string
  local q=$(jq -r --argjson q "$opt_query" '( . + (if ($q | length) > 0 then {"query":($q|@uri)} else {} end)) | to_entries | map("\(.key)=\(.value)") | join("&")' <<< $opt_req)

  v_curl -s ${UCR_API_URL}/service\?${q}
}

# TODO: install and uninstall

function ucr_service_get {
  local service=${1:?Need service name}

  v_curl -s ${UCR_API_URL}/service/${(L)service}
}

####################

function ucr_help_template_update {
  cat <<EOF
ucr template update [<github repo url>]
  Request a solution to update to the project on Github.
  If url omitted, then will try to build one from current directory git remote
EOF
}
function ucr_template_update {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local repo_url
  if [[ $# > 0 ]]; then
    repo_url=$1
  else
    repo_url=https://github.com/${${$(git remote get-url origin)#git@github.com:}%%.git}
    repo_url+="/tree/$(git rev-parse --abbrev-ref HEAD)"
  fi
  local req=$(jq -n -c --arg url "$repo_url" '{"url": $url}')
  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/update \
    -H 'Content-Type: application/json' \
    -d "$req"
}

function ucr_help_logs {
  cat <<EOF
ucr logs [--limit=] [--offset=]
  Get solution logs
EOF
}
function ucr_logs {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*" \
    offset "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4

  local q=$(jq -r 'to_entries|map("\(.key)=\(.value)")|join("&")' <<< $opt_req)

  v_curl -s ${UCR_API_URL}/solution/${UCR_SID}/logs\?${q}
}

####################
# BizApi functions

function ucr_help_business_token {
  cat <<EOF
ucr business token
  Get a business token for the business in UCR_BID.
  Requires UCR_BIZ_URL and UCR_BID to be set.
  Requires UCR_USER and UCR_PASSWORD to be set for authentication.
  If either are prefixed with 'op:', then 1Password will be used to get the actual values.

  All other business tasks require this token to operate and automatically call this.
EOF
}
function ucr_business_token {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token
  echo "$UCR_TOKEN"
}

function ucr_help_business_solutions {
  cat <<EOF
ucr business solutions
  List all solutions for the business 
EOF
}
function ucr_business_solutions {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}/solution/" \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

function ucr_help_business_solution_delete {
  cat <<EOF
ucr business solution delete <solution id>
  Deletes a solution from a business
EOF
}
function ucr_business_solution_delete {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  local sid=${1:?Need solution id}
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}/solution/${sid}" -X DELETE \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

function ucr_help_business_solution_get {
  cat <<EOF
ucr business solution get <solution id>
  Gets solution info from a business
EOF
}
function ucr_business_get {
  want_envs UCR_BIZ_URL "$ucr_biz_url_pattern" UCR_BID "^[a-zA-Z0-9]+$"
  get_token

  v_curl -s "${UCR_BIZ_URL}/business/${UCR_BID}" \
    -H 'Content-Type: application/json' \
    -H "Authorization: token $UCR_TOKEN"
}

#########################################################################

function ucr_help_sc {
  cat <<EOF
ucr sc <service> [--listops] [--no-cache] [--in=FILE] <operation> [--listparams] [options]
  Call a service operation.
  Use --listops to list the operations for the service.
  Use --listparams to list the parameters for the operation.
  Use --no-cache to force fetching the operations from the API. (still updates cache)
  Use --in=FILE to read parameters from a JSON file in addition to command line options.
  If FILE is '-', read from STDIN.

  Options are mapped to parameters by name, and validated against the parameter pattern if provided.
  All parameters are passed as options, none are positional.
  If both options and --in are given, the options override any values in the file.

  Note: This is a generic interface, and does not provide any special handling for specific services or operations.
EOF
}
function ucr_sc {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_DIS_URL "$ucr_dis_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local service=${1:?Need service name}

  # Check cache for service operations, if missing or older than a week, fetch new.
  # If --no-cache, always fetch new.
  local cache_file="${XDG_CACHE_HOME:-$HOME/.cache}/ucr/${service}-schema.json"
  mkdir -p ${cache_file:h}
  # If it doesn't exist, cache is false
  [[ -f $cache_file ]] || ucr_opts[cache]=false
  # If it exists, then check the age (this will set ucr_opts[cache] to false if too old)
  [[ -f $cache_file && -z "${cache_file}(N,md-7)" ]] && ucr_opts[cache]=false
  if [[ ${ucr_opts[cache]} == "false" ]]; then
    local ecf=$(mktemp -t sc-cache.ecf.XXXXXX)
    v_curl -s ${UCR_API_URL}/service/${(L)service}/schema \
      --write-out "%output{>>${ecf}}%{exitcode},%{http_code},%{errormsg}" \
      -o $cache_file
      local ec http_code errormsg
      IFS=',' read -r ec http_code errormsg < $ecf
      if [[ $ec != "0" || $http_code != "200" ]]; then
        echo "Error fetching schema for service $service: $http_code $errormsg" >&2
        rm -f $cache_file
        rm -f $ecf
        exit 2
      fi
      rm -f $ecf
  fi
  # Cache_file is a JSON formatted OpenAPI v2 schema for the service
  # v3 isn't supported by Murano yet.
  # Assumptions are made

  # --listops will just list the operations for the service
  # output is 'xdh $operationId' where the xdh only appear when respective flag is true
  if [[ -n "$ucr_opts[listops]" ]]; then
    jq '.paths
      | to_entries[]
      | .value
      | to_entries[]
      | .value
      | select(type == "object")
      | {
        operationId: .operationId,
        hidden: (.["x-exosite-hidden"] // false),
        restricted: (.["x-exosite-restricted"] // false),
        deprecated: (.["x-exosite-deprecated"] // false)
      }' $cache_file | mlr --ijson --opprint put '
        if ($hidden == true) { $h = "h" } else { $h = " " }
        if ($restricted == true) { $x = "x" } else { $x = " " }
        if ($deprecated == true) { $d = "d" } else { $d = " " }
        $flags = $x . $d . $h' \
        then cut -o -f flags,operationId \
        then sort -f operationId
    return
  fi

  local operation=${2:?Need operation name}
  shift 2
  # Check that the operation exists
  local have_op=$(jq --arg opId "$operation" '.paths
      | to_entries[]
      | .value
      | to_entries[]
      | .value
      | select(type == "object" and .operationId == $opId)' $cache_file)
  if [[ -z "$have_op" ]]; then
    echo "Operation `$operation` not found for service $service" >&2
    exit 3
  fi

  # Get the parameters for the operation
  # Note: This does not fully follow all $refs, instead only following the minimum needed to get the param_patterns built.
  # Currently does not handle patternProperties
  # Cannot handle both additionalProperties=true and defined properties in body parameters.
  local operation_parameters=$(jq --arg opId "$operation" 'def deref($d):
    if has("$ref") then ((.["$ref"] | split("/") | .[1:]) as $p | $d | getpath($p)) else . end;
  . as $doc
  | .paths
  | . as $paths
  | paths(type=="object" and .operationId == $opId)
  | reduce .[] as $item ( []; . + [ (.[-1] // []) + [$item] ] )
  | map(. + ["parameters"])
  | reduce .[] as $p ([]; . + ($paths | getpath($p)) )
  | map(
    deref($doc)
    | select(has("x-exosite-restricted") | not)
    | if has("in") and .in == "body" then
    		.name as $name
        | .schema
        | deref($doc)
        | if has("additionalProperties") and (.additionalProperties == true) and (has("properties") | not) then
          . + {"name": $name}
        else
          .properties // {} | to_entries[] | {"name": .key} + (.value // {} | deref($doc))
        end
      else
        .
      end
  )' $cache_file)

  [[ -z "${ucr_opts[debug]}" ]] || echo "Operation parameters: $operation_parameters" >&2

  local opt_req='{}'
  if [[ $(jq 'length' <<< $operation_parameters) > 0 ]]; then
    local param_patterns=($(jq -r '.[] |
    	.type |= if (.|type) == "array" then
        "object"
      else
        .
      end |
      .rex = if (.|has("pattern")) then
        .pattern
      elif (.| has("enum")) then
        "^(" + (.enum|join("|")) + ")$"
      elif .type == "string" then
        "^.*$"
      elif .type == "integer" then
        "^[0-9]+$"
      elif .type == "number" then
        "^[0-9]+(\\.[0-9]+)?$"
      elif .type == "boolean" then
        "^(true|1|yes|ok|y|t|false|no|n|f)$"
      else
        "^.*$"
      end |
      "\(if (. | has("x-exosite-from")) then .["x-exosite-from"] else .name end)::\(.type)", "\(.rex)"' <<< $operation_parameters))
    # echo "= = $param_patterns" >&2
    [[ -n "$param_patterns" ]] && opt_req=$( options_to_json "${(@)param_patterns}")
    [[ -z "$opt_req" ]] && exit 4
  fi

  # --listparams will just list the paramaters for the operation
  if [[ -n "$ucr_opts[listparams]" ]]; then
    if [[ $(jq 'length' <<< $operation_parameters) > 0 ]]; then
      for (( i=1; i<=$#param_patterns; i+=2 )); do
        local key=${param_patterns[i]%%::*}
        local type=${param_patterns[i]#*::}
        local rex=${param_patterns[i+1]}
        echo " --$key=<${type} by $rex>"
      done
      return
    else
      echo "No parameters for operation $operation" >&2
      return
    fi
  fi

  if [[ -n "${ucr_opts[in]}" ]]; then
    local file=${ucr_opts[in]}
    # If --in is `-`, use STDIN
    [[ "$file" == "-" ]] && file=/dev/stdin
    # Merge with opt_req
    opt_req=$(jq --argjson opt "$opt_req" '. * $opt' $file)
  fi

  _dis_call "${(L)service}" "${operation}" "$opt_req"
}

function _dis_call {
  want_envs UCR_DIS_URL "$ucr_dis_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Internal function to call the dispatcher
  local service=$1
  local operation=$2
  local data="$3"

  local ecf=$(mktemp -t discall.ecf.XXXXXX)

  local res=$(v_curl -s ${UCR_DIS_URL}/call/${UCR_SID}/${(L)service}/${operation}\?noWrap\=true \
    --write-out "%output{>>${ecf}}%{http_code},%{content_type}" \
    -H 'Content-Type: application/json' \
    -d "$data" 
  )

  local ec content_type
  IFS=',' read -r ec content_type < $ecf
  if [[ -n "${ucr_opts[debug]}" ]]; then
    echo "Status: $ec Type: $content_type" >&2
  fi
  # while _technically_ dispatcher should only ever return application/json, reality is not so kind.
  if [[ -n "${ucr_opts[raw]}" ]]; then
    content_type="application/octet-stream"
  elif [[ -n "${ucr_opts[contenttype]}" ]]; then
    content_type=${ucr_opts[contenttype]}
  elif [[ -z "$content_type" ]]; then
    content_type="application/octet-stream"
  else
    content_type=${content_type%%;*} # strip any charset or other params
  fi

  ec=$((ec))
  rm -f $ecf
  if [[ $ec > 400 ]]; then
    echo "Error calling ${(L)service}.${operation} [${ec}]:" >&2
  fi

  if [[ $content_type == "application/json" ]]; then
    jq  <<< "$res"
  else
    print "$res"
  fi
}

#########################################################################
# Below are Service specific abstractions

####################
# TSDB service

function ucr_help_tsdb_query {
  cat <<EOF
ucr tsdb query [<options>] <metric>… [<tag name>@<tag value>…]
  Query time series data.
  Metric names are just args, tags are <tag name>@<tag value>
EOF
if [[ -z "${ucr_opts[short]}" ]]; then
  cat <<EOF
  Options:
    --start_time=<time>        Start time for the query.
                               (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --end_time=<time>          End time for the query.
                               (e.g. 1633123200000ms or 1633123200s or RFC3339 UTC string)
    --relative_start=<time>    Relative start time for the query. (e.g. -1d, -12h, -30m)
    --relative_end=<time>      Relative end time for the query. (e.g. -1d, -12h, -30m)
    --sampling_size=<time>     Sampling size for downsampling. (e.g. 1m, 5m, 1h)
    --limit=<number>           Limit the number of data points returned.
    --epoch=(u|ms|s)           Return timestamps in microseconds, milliseconds, or seconds.
                               Defaults to RFC3339 UTC.
    --mode=(merge|split)       Merge all metrics into a single time series, or split into multiple
                               series by tag combinations. Default is merge.
    --fill=(null|previous|none|<number>|~s:.+) 
                               Fill missing data points with null, previous value, no fill, a
                               specific number, or a string.  Only in mode=merge.
    --order_by=(desc|asc)      Order results by timestamp descending or ascending. Default is desc.
    --aggregate=(avg|min|max|count|sum),+ 
                               Aggregate data points using the specified functions.
                               Can specify multiple functions separated by commas.
                               Note: aggregate requires sampling_size to be set.
EOF
  fi
}
function ucr_tsdb_query {
  # metric names are just args, tags are <tag name>@<tag value>
  # others are all --options=value
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Validate a list of the options we will care about.
  local opt_req=$(
    options_to_json \
    start_time "[0-9]*(u|ms|s)?" \
    end_time "[1-9][0-9]*(u|ms|s)?" \
    relative_start "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    relative_end "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    sampling_size "[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    limit "[1-9][0-9]*" \
    epoch "(u|ms|s)" \
    mode "(merge|split)" \
    fill "(null|previous|none|[1-9][0-9]*|~s:.+)" \
    order_by "(desc|asc)" \
    aggregate "((avg|min|max|count|sum),?)+"
  )
  [[ -z "$opt_req" ]] && exit 4

  local req=$(jq -c '. + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    {
      "tags": map(select(.value)) | group_by(.key) | map({"key":.[0].key,"value":(map(.value) | if length==1 then first else . end)}) | from_entries,
      "metrics": map(select(.value | not) | .key)
    })' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb query "$req"
}

function ucr_help_tsdb_list_tags {
  cat <<EOF
ucr tsdb list tags
  List all tag names.
EOF
}
function ucr_tsdb_list_tags {
  _dis_call tsdb listTags '' | jq '.tags | keys'
}

function ucr_help_tsdb_list_metrics {
  cat <<EOF
ucr tsdb list metrics
  List all metric names.
EOF
}
function ucr_tsdb_list_metrics {
  _dis_call tsdb listMetrics '' | jq .metrics
  # someday: Look for .next, and handle repeated calls if need be
}

function ucr_help_tsdb_exports {
  cat <<EOF
ucr tsdb exports
  List all export jobs.
EOF
}
function ucr_tsdb_exports {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local opt_req=$(
    options_to_json \
    limit "[1-9][0-9]*"
  )
  [[ -z "$opt_req" ]] && exit 4

  _dis_call tsdb exportJobList "$opt_req" 
}

function ucr_help_tsdb_export_info {
  cat <<EOF
ucr tsdb export_info <job id>
  Get information about a specific export job.
EOF
}
function ucr_tsdb_export_info {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local job_id=${1:?Need job id argument}

  _dis_call tsdb exportJobInfo "{\"job_id\":\"${job_id}\"}"
}

function ucr_help_tsdb_export {
  cat <<EOF
ucr tsdb export [<options>] <metric>… [<tag name>@<tag value>…] [<formatting>…]
  Export time series data to a CSV file.
EOF
if [[ -z "${ucr_opts[short]}" ]]; then
  cat <<EOF
  Metric names are just args, tags are <tag name>@<tag value>, formats are <metric>#<action>#<value>
  Options:
    --output=<filename>      Output file name. Defaults to <timestamp>_auto.csv
    --start_time=<time>      Start time for the query.
                             (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --end_time=<time>        End time for the query.
                             (e.g. 1633036800000ms or 1633036800s or RFC3339 UTC string)
    --relative_start=<time>  Relative start time for the query.  (e.g. -1h)
    --relative_end=<time>    Relative end time for the query.  (e.g. -1h)
    --limit=<number>         Limit the number of results.  (e.g. 100)
    --epoch=<unit>           Epoch time unit.  (e.g. s, ms, us) Defaults to RFC3339 UTC.
    --fill=<method>          Fill method for missing data. (e.g. previous, null)
    --order_by=<field>       Order results by a specific field. (e.g. timestamp)

    --timestamp=<time format>
                             Apply a datetime format to the timestamp column.
                             (e.g. %Y-%m-%dT%H:%M:%S.%f%z)
    --offset=<hours>         Offset to apply to the timestamp. (e.g. -4 for EDT)
    --include=<tags>         Comma-separated list of which tags to include in the export.
                             (e.g. tag1,tag2)
                             Default is to exclude all tags.

  Formatting:
    ORDER MATTERS! FE: round before label is different than label before round
    
    <metric>#label#<string>
    3456789#label#foo
      Prefix value with 'foo'
    
    <metric>#round#<number>
    3456789#round#9
      Round by 9
    
    <metric>#rename#<string>
    34567890#rename#bob
      Replace metric name with 'bob'
    
    <metric>#replace#<regexp>#<replace>
    123456#replace#([0-9])([0-9])#\2-\1
      Do regexp on value. replace uses '\1' for capture groups.
    
    <metric>|timestamp#datetime#<date format>#<offset>
    98765#datetime#year_%Y#-4
      Apply a datetime format to the value. Value should be microseconds since the EPOCH.
      Can use the '--timestamp' and '--offset' to shortcut for the 'timestamp' column.
EOF
  fi
}
function ucr_tsdb_export {
  # metric names are just args, tags are <tag name>@<tag value>, formats are <metric>#<action>#<value>
  #
  # Formating parameters:
  # ORDER MATTERS! FE: round before label is different than label before round
  #
  # <metric>#label#<string>
  # 3456789#label#foo
  #   Prefix value with 'foo'
  #
  # <metric>#round#<number>
  # 3456789#round#9
  #   Round by 9
  #
  # <metric>#rename#<string>
  # 34567890#rename#bob
  #   Replace metric name with 'bob'
  #
  # <metric>#replace#<regexp>#<replace>
  # 123456#replace#([0-9])([0-9])#\2-\1
  #   Do regexp on value. replace uses '\1' for capture groups.
  #
  # <metric>|timestamp#datetime#<date format>#<offset>
  # 98765#datetime#year_%Y#-4
  #   Apply a datetime format to the value. Value should be microseconds since the EPOCH.
  #   Can use the `--timestamp` and `--offset` to shortcut for the `timestamp` column.

  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # Validate a list of the options we will care about.
  # Ignored query options: (passing them does nothing)
  #  mode "(merge|split)"
  # Illegal query options: (passing them returns error)
  #  sampling_size "[1-9][0-9]*(u|ms|s|m|h|d|w)?"
  #  aggregate "((avg|min|max|count|sum),?)+" 
  local opt_req=$(
    options_to_json \
    start_time "[1-9][0-9]*(u|ms|s)?" \
    end_time "[1-9][0-9]*(u|ms|s)?" \
    relative_start "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    relative_end "-[1-9][0-9]*(u|ms|s|m|h|d|w)?" \
    limit "[1-9][0-9]*" \
    epoch "(u|ms|s)" \
    fill "(null|previous|none|[1-9][0-9]*|~s:.+)" \
    order_by "(desc|asc)"
  )
  [[ -z "$opt_req" ]] && exit 4

  # A few filtering only options.
  # These are all just once things, so it is cleaner to have them as options than as the '#' syntax
  local formated=$(
    options_to_json \
    timestamp ".*"\
    offset "-?[1-9][0-9]*" \
    include "[a-zA-Z0-9_,]+"
  )
  [[ -z "$formated" ]] && exit 4

  local filename=${ucr_opts[output]}
  if [[ -z "$filename" ]]; then
    filename="$(date +%s)_auto.csv"
  fi
  # if [[ "$filename" =~ "[\r\n\t\f\v ]" ]]; then
  #   echo "output file name cannot have spaces ($filename)" >&2
  #   exit 5
  # fi


  local req=$(jq --arg fn "$filename" --argjson ft "$formated" '{
    "query": (. + ($ARGS.positional | {
      "tags": ([.[] | select(contains("@")) | split("@") | {"key": .[0], "value": .[1]}] | group_by(.key) |
        map({"key":.[0].key,"value":(map(.value) | if length==1 then first else . end)}) | from_entries),
      "metrics": [.[]|select(contains("@") or contains("#")|not)]
    })),
    "filename": $fn,
    "format": (($ARGS.positional | [.[] | select(contains("#")) | split("#") | {
        "metric": .[0], "fn": .[1], "a": .[2], "b": .[3]
      }] | group_by(.metric) | map({"key":.[0].metric, "value": map(
        if .fn == "round" then {"round": .a|tonumber}
        elif .fn == "replace" then {replace: { match: .a, to: .b } }
        elif .fn == "datetime" then {datetime: { dt_format: (.a // "%Y-%m-%dT%H:%M:%S.%f%z"), offset: (.b // 0 | tonumber) }}
        else { (.fn): .a }
        end
      )}) | from_entries ) + if ($ft|has("timestamp") or has("offset")) then
        { "timestamp": [{datetime:{dt_format: ($ft.timestamp // "%Y-%m-%dT%H:%M:%S.%f%z"), offset: ($ft.offset // 0 | tonumber)}}] }
      else
        {}
      end + if ($ft|has("include")) then
        {"tags": [{normalize: $ft.include|split(",")}]}
      else
        {tags: [{discard: true}]}
      end
    )
  }' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb export "$req"
}

function ucr_help_tsdb_write {
  cat <<EOF
ucr tsdb write [--ts=<timestamp>] <metric> <value> [<metric> <value> …] [<tag>@<value> …]
  Write time series data points.
  Metric names and values are pairs of args, tags are <tag name>@<tag value>
EOF
}
function ucr_tsdb_write {
  # write [--ts=<timestamp>] <metric> <value> [<metric> <value> …] [<tag>@<value> …]
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"

  local opt_req=$(options_to_json ts "[1-9][0-9]*(u|ms|s)?") # ??? does ts take suffixes?
  [[ -z "$opt_req" ]] && exit 4

  local req=$(jq -c 'def nwise($n): while(.!=[]; .[$n:])[:$n]; . + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    { "tags": (map(select(.value)) | from_entries),
      "metrics": ([map(select(.value|not)|.key) | nwise(2) | {"key": .[0], "value": .[1]}] | from_entries)
    })' --args -- "${@}" <<< $opt_req)

  _dis_call tsdb write "$req"
}

####################
# Keystore service

function ucr_help_keystore_list {
  cat <<EOF
ucr keystore list [<match>]
  List keys in the keystore. Optionally filter by match pattern (default '*')
EOF
}
function ucr_keystore_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local match=${1:-*}
  local req=$(jq -n -c --arg match "$match" '{"match":$match,"cursor":0}')

  _dis_call keystore list "$req"
}

function ucr_help_keystore_get {
  cat <<EOF
ucr keystore get <key> [<key> …]
  Get one or more keys from the keystore.
EOF
}
function ucr_keystore_get {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  [[ $# == 0 ]] && echo "Missing keys to get" >&2 && exit 2
  local req=$(jq -n -c '{"keys":$ARGS.positional}' --args -- "${@}")

  _dis_call keystore mget "$req"
}

function ucr_help_keystore_set {
  cat <<EOF
ucr keystore set <key> <value>
  Set a key in the keystore. Use '-' as value to read from STDIN.
  (atm there is no way to set a value of '-')
EOF
}
function ucr_keystore_set {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local key=${1:?Need key argument}
  local value=${2:?Need value to set}
  if [[ "$value" = "-" ]]; then
    value=$(</dev/stdin)
  fi

  local req=$(jq -n -c --arg key "$key" --arg value "$value" '{"key":$key,"value":$value}')

  _dis_call keystore set "$req"
}

function ucr_help_keystore_delete {
  cat <<EOF
ucr keystore delete <key> [<key> …]
  Delete one or more keys from the keystore.
EOF
}
function ucr_keystore_delete {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  [[ $# == 0 ]] && echo "Missing keys to delete" >&2 && exit 2
  local req=$(jq -n -c '{"keys":$ARGS.positional}' --args -- "${@}")

  _dis_call keystore mdelete "$req"
}

function ucr_help_keystore_cmd {
  cat <<EOF
ucr keystore cmd <key> <command> [<arg> …]
  Execute a command on a key in the keystore.
EOF
}
function ucr_keystore_cmd {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cmd=${1:?Need command argument}
  local key=${2:?Need key argument}
  shift 2
  local req=$(jq -n -c --arg key "$key" --arg cmd "$cmd" \
    '{"key":$key,"command":$cmd, "args": $ARGS.positional}' \
    --args -- "${@}")

  _dis_call keystore command "$req"
}

####################

function ucr_help_content_info {
  cat <<EOF
ucr content info <content id>
  Returns information about the specified content.
EOF
}
function ucr_content_info {
  local id=${1:?Need file id}
  local req="{\"id\": \"$id\"}"

	_dis_call content info "$req"
}

function ucr_help_content_list {
  cat <<EOF
ucr content list [--op=AND|OR] [--stop=#] [<prefix filter>] [<tag name filter>@<tag value filter> ...]
  Lists content matching the specified filters.
  --op determines if multiple tag filters are ANDed or ORed. Default is AND.
  --stop limits the number of results returned. Default is no limit.
EOF
}
function ucr_content_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  # list [--op=AND|OR] [--stop=#] [<prefix filter>] [<tag name filter>@<tag value filter> ...]
  local opt_req=$(options_to_json \
    op "^(AND|OR)$" 
  )
  [[ -z "$opt_req" ]] && exit 4

  local p_req=$(jq -c '. + ($ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) |
    {
      "tags": (map(select(.value)) | from_entries | tojson),
      "prefix": (map(select(.value|not)|.key) | first),
      "full": true
    } | del(.[] | select(. == null)))' --args -- "${@}" <<< $opt_req)

  local prior_count=1
  local total_count=0
  local stop_after=${ucr_opts[stop]:-999999999}
  local cursor=''

  # first call always happens and has no cursor.
  local ret=$( _dis_call content list "$p_req")
  prior_count=$(jq -r length <<< $ret)
  total_count=$(( total_count + prior_count ))
  cursor=$(jq -r 'last | .id' <<< $ret)
  # Now 'stream' results
  jq -c -M '.[]' <<< $ret

  # Loop advancing cursor until an empty reply
  while [[ prior_count -gt 0 && total_count -lt stop_after ]]; do
    local req=$(jq -c --arg cursor "$cursor" '. + {"cursor": $cursor}' <<< $p_req)
    local ret=$(_dis_call content list "$req")
    prior_count=$(jq -r length <<< $ret)
    total_count=$(( total_count + prior_count ))
    cursor=$(jq -r 'last | .id' <<< $ret)
    # Now 'stream' results
    jq -c -M '.[]' <<< $ret
  done
}

function ucr_help_content_delete {
  cat <<EOF
ucr content delete <content id> [<content id> ...]
  Deletes the specified content.
EOF
}
function ucr_content_delete {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local req=$(jq -n -c '{ "body" : $ARGS.positional }' --args -- "$@")

  _dis_call content deleteMulti "$req"
}

function ucr_help_content_download {
  cat <<EOF
ucr content download <content id> [--expires_in=<seconds>]
  Returns a URL to download content from.
  --expires_in determines how long the URL is valid for.
EOF
}
function ucr_content_download {
  # doesn't actually download, just returns a URL to download from.
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cid=${1:?Need content id to download}
  local opt_req=$(options_to_json \
    expires_in "^\d+$" \
  )
  [[ -z "$opt_req" ]] && exit 4
  local req=$(jq -c --arg cid "$cid" '. + {"id": $cid|@uri }' <<< $opt_req)

  _dis_call content download "$req"
}

function ucr_help_content_upload {
  cat <<EOF
ucr content upload <content id> [--expires_in=<seconds>] [--type=<mime type>]
  Returns a curl command line to upload content to.
  --expires_in determines how long the URL is valid for.
EOF
}
function ucr_content_upload {
  # Doesn't actually upload, just returns a cURL to upload to.
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local cid=${1:?Need content id to upload}
  local opt_req=$(options_to_json \
    expires_in "^\d+$" \
    type "^.+$" \
  )
  [[ -z "$opt_req" ]] && exit 4

  # A GET req with url encoded file name and query options for the rest.
  local req=$(jq -n -c --arg cid "$cid" '{"id": $cid|@uri }')
  local psu=$(_dis_call content upload "$req")

  # Convert to new curl params
  local params=($(jq '(.inputs|to_entries|[.[]|"-F", "\"\(.key)=\(.value)\""]) + (["-F", "\"\(.field)=@\(.id)\"", .url]) |.[]' -r <<< $psu))
  echo curl -X POST "${params[@]}"
}

##################################################

function ucr_help_device_add {
  cat <<EOF
ucr device add <did>
  Adds a device to the allowlist.
  "ucr device activate" must be called afterwards to be able to write to it.
EOF
}
function ucr_device_add {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local did=${1:?Need device id}
  local req=$(jq -c -n --arg did "$did" '{"identity": $did, locked: false}')
  _dis_call device2 addIdentity "$req"
}

function ucr_help_device_list {
  cat <<EOF
ucr device list
  Lists all devices.
EOF
}
function ucr_device_list {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  _dis_call device2 listIdentities ""
}

function ucr_help_device_info {
  cat <<EOF
ucr device info <did>
  Displays information about device service
EOF
}
function ucr_device_info {
  ucr_service_details device2
}

function ucr_help_device_state {
  cat <<EOF
ucr device state <did>
  Displays the current state of a device.
  This includes the set and reported values for resources.
EOF
}
function ucr_device_state {
  want_envs UCR_API_URL "$ucr_api_url_pattern" UCR_SID "^[a-zA-Z0-9]+$"
  local did=${1:?Need device id}
  local req=$(jq -c -n --arg did "$did" '{"identity": $did}')
  _dis_call device2 getIdentityState "$req"
}

# This sets via the cloud side API.
# function ucr_device_state_set { }

function ucr_help_device_write {
  cat <<EOF
ucr device write <did> <resource> <value>
  Records a resource value via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_write {
  # This writes via the external HTTP API.
  # Only one resource at a time for now. Could expand to allow multiple, but not needed today.
  # ucr device write <did> <resource> <value>
  local did=${1:?Need device id}
  local res=${2:?Need a resource to write}
  local val=${3:?Need a value}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)
  local vm=$(jq -r .solution_id <<< $details)
  local cik=$UCR_CIK
  # if UCR_CIK_<did> is set, use that instead
  local cik_var="UCR_CIK_${did}"
  if [[ -n "${(P)${cik_var}}" ]]; then
    cik=${(P)${cik_var}}
  fi

  # server actually only supports a subset of form-urlencoded, so manually pack it
  val=$(jq -r '@uri' <<< $val)
  v_curl -s https://${d_host}/onep:v1/stack/alias \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8' \
    -H "Authorization: token ${cik}" \
    -d "${res}=${val}"
}

function ucr_help_device_record {
  cat <<EOF
ucr device record <did> <resource> <ts> <value>
  Records a resource value via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_record {
  # This writes via the external HTTP API.
  # Only one resource at a time for now. Could expand to allow multiple, but not needed today.
  # ucr device record <did> <resource> <ts> <value>
  local did=${1:?Need device id}
  local res=${2:?Need a resource to write}
  local ts=${3:?Need a timestamp}
  local val=${4:?Need a value}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)
  local vm=$(jq -r .solution_id <<< $details)
  local cik=$UCR_CIK
  # if UCR_CIK_<did> is set, use that instead
  local cik_var="UCR_CIK_${did}"
  if [[ -n "${(P)${cik_var}}" ]]; then
    cik=${(P)${cik_var}}
  fi

  # server actually only supports a subset of form-urlencoded, so manually pack it
  val=$(jq -r '@uri' <<< $val)
  v_curl -s https://${d_host}/onep:v1/stack/record \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8' \
    -H "Authorization: token ${cik}" \
    -d "alias=${res}&${ts}=${val}"
}

function ucr_help_device_exo_write {
  cat <<EOF
ucr device exo write <did> <channel> <value> [<channel> <value> ...]
  Writes channel values via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_exo_write {
  # ExoSense wraps channels into a data_in resource
  # ucr device exo write <did> <channel> <value> [<channel> <value> ...]
  # TODO: Add a way to set channel values as JSON
  local did=${1:?Need device id}
  [[ $# -lt 3 ]] && echo "Need at least 3 arguments" >&2 && exit 2
  shift
  # take args and turn into a JSON object
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n];. + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  ucr_device_write "$did" data_in "$req"
}

function ucr_help_device_exo_record {
  cat <<EOF
ucr device exo record <did> <ts> <channel> <value> [<channel> <value> ...]
  Records channel values via the external HTTP API.
  Looks up the CIK via ENV as "UCR_CIK_\${did}"
EOF
}
function ucr_device_exo_record {
  # ExoSense wraps channels into a data_in resource
  # ucr device exo write <did> <ts> <channel> <value> [<channel> <value> ...]
  local did=${1:?Need device id}
  local ts=${2:?Need a timestamp}
  [[ $# -lt 4 ]] && echo "Need at least 4 arguments" >&2 && exit 2
  shift 2
  # take args and turn into a JSON object
  local req=$(jq -n -c 'def nwise($n): while(.!=[]; .[$n:])[:$n];. + ([$ARGS.positional|nwise(2)|{"key":.[0],"value":.[1]}]|from_entries)' --args -- "${@}")

  ucr_device_record "$did" data_in "$ts" "$req"
}

function ucr_help_device_confirm {
  cat <<EOF
ucr device confirm <did> [<resource>]
  Confirms the set value of a resource by reporting it.
  The device must be active for this to work.

  <resource> defaults to 'config_io'
EOF
}
function ucr_device_confirm {
  local did=${1:?Need device id}
  local rid=${2:-config_io}

  local state=$(ucr_device_state "$did" | jq -r --arg rid "$rid" '.[$rid].set')
  ucr_device_write "$did" "$rid" "$state"
}

function ucr_help_device_activate {
  cat <<EOF
ucr device activate <did>
  Activates a device via the external HTTP API.
EOF
}
function ucr_device_activate {
  # This activates via the external HTTP API.
  local did=${1:?Need device id}
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)

  # server actually only supports a subset of form-urlencoded, so manually pack it
  # did=$(jq -r '@uri' <<< $did)
  v_curl -s https://${d_host}/provision/activate \
    -d "id=${did}" \
    -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8'
}

function ucr_help_device_content_upload {
  cat <<EOS
ucr device content upload <did> <file> [<tag name>@<tag value> ...]
  Uploads a file as content associated with the device.
  Looks up the CIK via ENV as "UCR_CIK_\${did}", or uses UCR_CIK if that is not set.
  Tags are optional key/value pairs to associate with the content.
EOS
}
function ucr_device_content_upload {
  local did=${1:?Need device id}
  local fid=${2:?Need file to upload}
  shift 2
  local tags=''
  if [[ $# > 0 ]]; then
    tags=$(jq -n '$ARGS.positional | map(split("@") | {"key": .[0], "value": .[1]} ) | from_entries | @uri' --args -- "$@")
    tags="?tags=$tags"
  fi

  [[ ! -f "$fid" ]] && echo "File to upload not found: $fid" >&2 && return 2
  local details=$(ucr_service_details device2)
  local d_host=$(jq -r .parameters.fqdn <<< $details)
  local cik=$UCR_CIK
  # if UCR_CIK_<did> is set, use that instead
  local cik_var="UCR_CIK_${did}"
  if [[ -n "${(P)${cik_var}}" ]]; then
    cik=${(P)${cik_var}}
  fi

  local mimetype=$(file --mime-type -b "$fid")
  [[ -z "$mimetype" ]] && mimetype="application/octet-stream"

  v_curl -X PUT -s https://${d_host}/onep:v1/content/${fid}${tags} \
    -H "Content-Type: $mimetype" \
    -H "Authorization: token ${cik}" \
    --data-binary @$fid
}

##############################################################################
# Finally, run the task runner to find and run the task based on arguments
task_runner "$@"
